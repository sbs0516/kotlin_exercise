61. 호출 연산자(Invoke Operator) () : 함수를 호출할 때 사용하는 연산자

    operator fun invoke(value:Int) {} 로 오버로딩 가능. 매개변수(인수) 갯수는 자유.

62. in 연산자 : 어떤 값이 객체에 포함되어 있는지 여부 확인 (when 문에서도 사용 가능)

    println('o' in "Kotlin") -> true
    println("in" !in "Kotlin") -> false

    operator fun contains(매개변수:타입):Boolean 으로 오버로딩 가능. 매개변수 타입은 자유.

63. 멤버 함수의 중위 표기법(Infix Notation) : 피연산자-연산자-피연산자 순서로 표현식을 구성하는 방법

    infix fun from(base:Point):Point{
        return Point(x-base.x,y-base.y)
    }
    -> val pt = Point(3,6) from Point(1,1) 로 표현. <- Point(3,6).from(Point(1,1)) 의 문법적 설탕

64. 상속(Inheritance) : 기존에 있던 클래스를 확장하여 새로운 클래스 정의. 상속은 하나의 클래스만 가능. 연속 상속은 가능(서브 클래스를 다시 슈퍼 클래스로)
                       -> 상속은 클래스의 확장 보다는, 유사한 객체들을 하나의 타입으로 받을 수 있게 사용(다형성)

    상속하려면 부모 클래스(슈퍼 클래스) 앞에 open 붙여줌. 코틀린은 클래스 제한자가 기본 final
    자손 클래스(서브 클래스)에는 선언부 뒷쪽에 :(부모 클래스 생성자)(매개변수)
    ex)
    open class Person(val name:String, val age:Int)

    class Student(name:String, age:Int, val id:Int) : Person(name,age)
                                                      ----------------
                                                             ㄴ 부모 클래스(슈퍼 클래스)의 생성자 호출

65. 업캐스팅(Upcasting) : 형변환(Casting). 특정 타입을 다른 타입으로 변환. 서브 클래스의 인스턴스를 슈퍼 클래스 타입으로 변환 가능.

    open class Person(val name:String, val age:Int)

    class Student(name:String, age:Int, val id:Int) : Person(name,age)
    ---- main {
        val person:Person=Student("John",32,20171218) -> Student 가 Person 의 프로퍼티와 멤버함수를 가지고 있어서(상속)
                                                         val person : Person(타입) 으로 타입 변환 가능
    }

66. 오버라이딩(Overriding) : 슈퍼 클래스의 멤버 함수와 시그니처가 동일한 멤버 함수를 서브 클래스에서 선언하면,
                           슈퍼 클래스 멤버 함수의 동작을 덮어쓸 수 있음
                           상속과 마찬가지로 오버라이딩 하려는 함수 앞에는 open 붙여줌
                           오버라이딩 할 때는 함수 정의문 앞에 override
                           override 는 자체로 open 키워드 포함. override 된 함수는 서브 클래스에서 재오버라이딩 가능. 막으려면 final 붙여줘야함
                           -> final override fun func()

    open class AAA{
        open fun func()=println("AAA")
    }
    class BBB : AAA(){
        override fun func(){
            super.func()            -------------> super, 슈퍼 클래스의 func 함수 호출
            println("BBB")
        }
    }

67. 프로퍼티를 오버라이딩 하기 : 프로퍼티에도 Getter, Setter 가 존재하므로 오버라이딩 가능

68. 다형성(Polymorphism)의 활용

    open class AAA{
        open fun hello() = println("AAA 입니다")
    }
    class BBB : AAA(){
        override fun hello() = println("BBB 입니다")
    }
    fun main(){
        val one=AAA()
        val two=BBB()
        val three: AAA=two    -> AAA 타입 이지만 BBB 인스턴스 저장

        one.hello()         -> AAA 입니다
        two.hello()         -> BBB 입니다
        three.hello()       -> BBB 입니다
    }

69. 클래스를 상속하는 객체

    open class Person(val name:String, val age:Int){
        open fun print(){
            println("이름: $name")
            println("나이: $age")
        }
    }
    fun main(){
    val custom:Person = object : Person("Alan",23){  -> 객체를 만들면서 클래스 상속하려면 object 뒤에 슈퍼 클래스 생성자. 이 상속은 1회용
        override fun print(){
            println("It's a object")
        }
    }
    custom.print()
    }

70. Any 클래스 : 어떤 클래스가 아무 클래스도 상속하지 않으면 자동으로 Any 클래스 상속. Any 클래스는 최상위 클래스
                다른 클래스를 상속해도. 그 클래스 역시 Any 클래스는 자동으로 상속하므로 간접적으로 Any 클래스 상속

    Any 클래스의 세 가지 함수
    open class Any{
        open operator fun equals(other:Any?): Boolean  --> == 연산자를 오버로딩하는 멤버 함수
        open fun hashCode():Int                        --> 객체 고유의 해시코드 반환
        open fun toString():String                     --> 객체 내용을 String 으로 변환
    }

    ex)
    class Building(val name:String="", val date:String="", val area:Int=0){
        override fun toString() =
        "이름: ${this.name}\n"+"건축일자: ${this.date}\n"+"면적: ${this.area} m2" --> Any 클래스의 toString 오버라이딩
    }
    fun main(){
        val building = Building("코틀린", area = 100)
        printObject(building)
    }
    fun printObject(any:Any){
        println(any.toString())      --> Any 타입의 toString 호출해도 다형성으로 실제로는 building 객체의 toString 호출
    }                                    print 함수는 전달한 인수가 String 타입이 아니면 내부적으로
                                         println(any.toString())을 호출하므로, println(any) 만 써도 됨

71. 예외(Exception)

72. 예외 처리

    try{
        val str="abcd"
        val num=str.toInt()
        println(num)
    } catch (e: NumberFormatException) {
        println("문자열 숫자로 변경 불가")
    } finally {  ----------------------------> 예외와 상관 없이 무조건 실행되는 블록
        println("프로그램 종료")
    }                               ---------> 여러 종류의 예외를 처리하고 싶을 떈 catch 블록을 여러 개 작성

73. 예외 던지기 : 고의로 예외를 발생 시키는 것

    fun main(){
        try{
            something()
        } catch (e:Exception) {
            println(e.message)
        }
    }
    fun something(){
        val num1 = 10
        val num2 = 0
        div(num1,num2)
    }
    fun div(a:Int,b:Int):Int{
        if(b==0) throw Exception("0으로 나눌 수 없음")  --> throw Throwable 타입 표현식
        return a/b                                       예외가 던져지면 밑의 코드는 다 무시하고 함수 호출 코드로 돌아감
    }                                                --> fun something() 에는 예외 처리 코드가 없으므로, something 을 호출한
                                                         main 함수로 돌아감. 거기서 catch 예외 처리 실행. 여기도 예외 처리가 없으면
                                                         프로그램 강제 종료.
                                                         e.message 에는 throw 로 던진 "0으로 나눌 수 없음" 이 전달됨

74. Nothing 타입 : 실행 흐름이 도달할 수 없는 구역을 나타내기 위한 특수 타입

    fun throwing(): Nothing = throw Exception() --> 코틀린에서는 throw 표현식 문장도 표현식으로 취급 가능
    fun main(){
        println("start")
        val i:Int = throwing()                  --> Int 타입의 변수 i 에 Nothing 타입의 표현식 대입.
        println(i)                                  Nothing 은 어떤 타입과도 호환 가능.
    }

    -> Nothing 은 어디에 활용 ?

    fun validate(num:Int){
        val result: Int=
            if(num>0) num
            else throw Exception("num 이 음수 입니다") --> Nothing 표현식이기 때문에 if-else 가 Int 타입으로 인식됨
    }                                                    throw Exception 이 표현식이 아니라면,  Unit 타입으로 인식 되고
                                                         if-else 는 Int 와 Unit 로 호환이 되지 않음

75. Nullable 타입과 null : 타입 뒤에 ? 을 붙이면 변수를 Nullable 하게 만들 수 있음(변수에 null 값 지정 가능)
                          코틀린은 Nullable 이 아니면 null 값 절대 지정 못 함

    class Person(s:String, age:Int){}
    fun main(){
        var person: Person?=Person("K",30)
        person=null                             --> null 은 Nothing? 타입의 표현식이므로, null 을 Person? 에 대입 가능
                                                                        ㄴ Nothing 은 어떠한 타입과도 호환 가능
        var num: Int?=null                      --> Byte, long, Double, Int, Float, Char, Boolean, Short 에 ? 을 붙이면
        num=10                                      그 변수는 참조 변수가 되고, 실제 데이터는 힙 영역에 생성됨. 따라서 num = 10 에서
    }                                               10은 힙 영역에 저장

    if(true) "Test" else null --> if 는 String, else 는 Nothing 타입 이므로 String 으로 합쳐짐. if-else 표현식은 String 타입

76. 안전한 호출 연산자(Safe call Operator) ?. : Nullable 한 참조 변수의 프로퍼티와 멤버 함수에 접근하려면, . 이 아닌 ?. 로 접근해야함
                                             ex) 참조 변수?.멤버 함수() -> 참조 변수가 null 이면 함수 호출X. 해당 표현식 null
                                                 참조 변수?.프로퍼티    -> 참조 변수가 null 이면 해당 표현식 null
    fun main(){
        var obj: Building? = null
        obj?.print()                    -> obj 가 null 이므로 print 함수 무시. 표현식 값은 null, 타입은 Unit? 가 됨
        obj?.name = "건물"               -> obj 가 null 이므로 프로퍼티에 값을 저장하는 것도 무시
                                           (프로퍼티에 값 저장하는 것도 일종의 함수 호출. getter/setter 사용하므로)

        obj = Building()
        odj?.name = "서울월드컵경기장"      -> 여기부턴 obj 에 null 이 지정되어 있지 않으므로 프로퍼티에 정상적으로 값 저장 가능
        obj?.date = "2001년11월10일"
        obj?.area = 21_6712
        obj?.print()
    }

77. Not-null 단정 연산자(Not-null Assertion Operator) !! : !! 연산자는 Nullable 타입을 Not-null 타입으로 강제 캐스팅(형변환)

    fun main(){
        var obj: Building? = Building()
        obj!!.name="서울시청"
        println(obj!!.name)

        obj=null
        obj!!.print()                       --> obj 가 null 이므로 NullPointerException 발생
    }

78. 엘비스 연산자(Elvis Operator) ?: : 왼쪽의 피연산자가 null 이 아니면 그 값을 그대로, null 이면 우측의 피연산자로 대체

    fun main(){
        val number: Int? = null
        println(number ?: 0)    --> 0 출력

        val number2: Int? = 15
        println(number2 ?: 0)   --> number2 출력( 15는 Int? 때문에 힙 영역에 저장되고, number2 는 참조값이 저장되는 점 잊지 말 것)
    }
    --> 자바의 삼항 연산자를 코틀린에서는 더 간단하게 사용 가능
    String str="dd";
    ~~
    return (str!=null) ? str : "Hello"; --> return str ?: "Hello"

79. 스마트 캐스팅 : 특정 조건을 만족할 때, 컴파일러는 변수의 타입을 다른 타입으로 자동 캐스팅함

    fun main(){
        val number: Int? = null
        val number2 = 1225

        checkNull(number)
        checkNull(number2)
    }
    fun checkNull(any:Any?){
        if(any==null) {
            println("null 이 들어 있습니다")
            return
        }
        println(any.toString())    --> 이 코드까지 온 시점에서, any(특정 변수)는 null 값이 들어 있지 않다고 완벽히 추론 가능하므로
    }                                  컴파일러가 자동으로 any(특정 변수)를 Not-null 타입으로 지정. 때문에 toString() 호출 가능

80. is 연산자 : 참조 변수가 실제로 가리키고 있는 객체의 타입을 알아낼 수 있음 (자바의 instanceof)

    open class Person(val name:String, val age:Int)
    class Student(name:String, age:Int, val id:Int) : Person(name,age)
    class Professor(name:String, age:Int): Person(name,age)
    fun main(){
        val person: Person = Student("Mark", 33,20171225)

                                    --> is 연산자는 왼쪽 피연산자(참조 변수)가 실제로 가리키고 있는 객체를 오른쪽 피연산자(타입)으로
                                        가리킬 수 있는지 여부를 조사
        print("${person is Person")       -> person 은 실제로는 Student 가리킴. Student 는 Person 으로 가리킬 수 있음. true
        print("${person is Student")      -> true
        print("${person is Professor")    -> false

        val person2: Person = Professor("Kim", 48)
        print("${person2 is Person")      -> true
        print("${person2 is Student")     -> false
        print("${person2 !is Professor")  -> false
    }

    -> when 에서 사용 가능
    when(person){
        is Person -> {}
        is Student -> {}
        is Professor -> {}
    }

81. as 연산자와 다운 캐스팅 : 업캐스팅과는 반대로 슈퍼 클래스 타입을 서브 클래스 타입으로 받는 것을 뜻함

    open class Person{}
    class Student: Person{}
    fun main() {
        val person: Person = Student("John", 32, 20171218)
        val person2: Person = Person("Jack",29)
        var person3: Student = person as Student  --> person 은 Student 를 받고 있으므로 무사히 다운 캐스팅
        person3 = person2 as Student              --> person2 는 Person 을 받고 있으므로 다운 캐스팅 실패. ClassCastException 발생
    }                                                 예외 없애려면 as? 사용

82. 접근 지정자(Access Modifier) : 선언 가능한 요소(함수, 전역 변수, 클래스, 프로퍼티, 멤버 함수 등) 중, 일부 요소에 지정가능한 접근 권한

    public    : 모든 곳에서 접근 가능. 디폴트 값
    internal  : 같은 모듈 안에서만 접근 가능. Intellij 의 프로젝트 모듈.
    protected : 클래스 내부와 서브 클래스만 접근 가능
    private   : 프로퍼티와 멤버 함수의 경우 해당 클래스에서만 접근 가능하고, 그 외의 경우엔 같은 파일 내에서만 접근 가능

    class Rectangle(private val width: Int, private val height:Int) { --> width, height 는 Rectangle 클래스 에서만 사용 가능
        val area: Int
        get() = width*height
    }
    fun main() {
        val rect=Rectangle(5,7)
        // println(rect.width) // 에러                                --> width 는 Rectangle 클래스 에서만
        println(rect.area)                                           --> area 는 public(디폴트 지정자)
    }

83. 접근 지정자 private : 아래 예제의 public 은 전부 생략 가능

    private var num=10
    private fun print()=println(num)
    public fun hello(value:Int){
        num=value
        print()
    }
    public class Person(age:Int){
        public var age=age
        private set
        public val isYoung public get()=age<30
    }
-------------------------------------------------------다른 파일
    fun main() {
        // num=5                  --> private 라서 윗 파일에서만 사용 가능
        hello(15)                 --> public 가능
        val person=Person(10)     --> public class
        println(person.age)       --> public age 접근 가능
        // person.age=20          --> set 은 private
        println(person.isYoung)   --> isYoung 는 public
    }

84. 접근 지정자 protected

    open class AAA(protected val number: Int)
    class BBB(number: Int): AAA(number){ --> AAA 를 상속했기 때문에 protected 인 number 사용 가능
        fun printNumber(){
            println(number)
        }
    }
    fun main() {
        val test = BBB(36)
        // println(test.number)          --> AAA, BBB 외부에서 number 접근 불가
        test.printNumber()
    }

85. 접근 지정자 오버라이딩 : 오버라이딩으로 protected 인 프로퍼티나 멤버 함수를 public 으로 변경 가능
                         private 는 오버라이딩 불가능

    open class AAA(protected open val number: Int) {
        protected open fun hello(){
            println("hello")
        }
    }
    class BBB(number: Int): AAA(number){
        public override val number: Int
        get() = super.number
        public override fun hello()=super.hello()
    }
    fun main() {
        val b=BBB(26)
        val a: AAA=b
    //    println(a.number)         --> a 는 AAA 를 받고 있으므로 protected
    //    a.hello()                 --> a 는 AAA 를 받고 있으므로 protected
        println(b.number)           --> b 는 BBB 를 받고 있으므로 public 오버라이딩 완료
        b.hello()                   --> b 는 BBB 를 받고 있으므로 public 오버라이딩 완료
    }

86. 확장 함수(Extension Function) : 상속 없이 클래스 외부에서 멤버 함수 추가 가능
                                   함수 이름 앞에 '함수를 주입할 클래스.' 을 붙여주면 됨
                                                        ㄴ 리시버 타입
                                   클래스에 이미 존재하는 멤버 함수와 동일한 시그니처의 확장 함수가 있다면, 오류는 나지 않지만
                                   확장 함수가 가려져서 함수 호출 시 멤버 함수만 호출됨

    fun String.isNumber(): Boolean{
        var i=0
        while(i<this.length){                       --> this 를 사용하면 리시버 타입의 프로퍼티나 멤버 함수에 접근 가능. private 나 protected 는 불가
            if(!('0'<=this[i]&&this[i]<='9'))           여기서는 this = String.isNumber()
                return false
            i+=1
        }
        return true
    }
    fun main() {
        println("1234567890".isNumber())
        println("500원".isNumber())
    }

87. 확장 프로퍼티(Extension Property)
    -> 확장 프로퍼티에는 field 가 없으므로 field 식별자 사용 불가

    val String.isLarge: Boolean
    get() = this.length>=10              --> String.isLarge 가 10보다 크면 true
    fun main() {
        println("1234567890".isLarge)    --> isLarge 는 멤버 함수가 아닌 프로퍼티 이므로 호출 함수 () 없어도 됨
        println("500원".isLarge)
    }

88. 객체 선언(Object Declaration) : 프로그램 전체에서 공유할 수 있는 하나뿐인 객체가 필요할 때 사용

    object Person{
        var name: String = ""
        var age: Int = 0
        fun print(){
            println(name)
            println(age)
        }
    }
    fun main() {
        Person.name="Singleton"   --> Person 식별자 만으로 객체에 바로 접근 가능
        Person.age=45
        Person.print()
    }

89. 동반자 객체(Companion Object) : 클래스 안에 포함되는 이름 없는 객체. 어떤 클래스의 모든 인스턴스가 공유하는 객체를 만들고 싶을 때 사용
                                  Java 의 static 과 같음
    class Person private constructor(){
        companion object{
            fun create(): Person{
                countCreated+=1
                return Person()
            }
            var countCreated=0
            private set
        }
    }
    fun main() {
        val a=Person.create()           --> 동반자 객체는 자신이 속한 클래스의 이름으로 접근 가능. 동반자 객체는 클래스당 한 개만 존재
        val b=Person.create()           --> Person.Companion.create() 로도 호출 가능
        println(Person.countCreated)
    }

90. inline 함수 : 함수의 실행 흐름을 점프하지 않고 함수 호출문을 함수의 몸체로 대체하여 성능 다소 개선
                 inline 함수는 함수 속의 문장을 재활용하지 않으므로 모든 함수를 inline 으로 쓰는 것은 안 됨.
                 문장이 적고 빈번히 호출되는 함수만 권장. 재귀 호출도 불가능(몸체 코드가 무한대로 늘어날 수 있음)

    inline fun hello(){
        println("hello")
        println("Kotlin")
    }
    fun main() {
        hello()             --> 이 호출문이 컴파일 되는 순간 println("hello")
        hello()                                         println("Kotlin") 으로 대체됨. 아래 두 줄의 hello() 도 마찬가지
        hello()
    }

91. const : val 변수 앞에 const 를 붙이면 변수에 접근하는 코드를 변수에 저장된 값으로 대체시킴
            const 가 붙은 변수에는 리터럴로 이루어진 표현식만 저장 가능
            코틀린 문법 중에는 리터럴만 와야 하는 자리가 몇 군데 있으므로 그 곳에 사용하면 좋음(const 가 붙으면 변수가 리터럴로 대체되므로)

    const val hello = "Hello"+"World!"
    object Foo{
        const val bar="bar"
    }
    fun main() {
        println(hello)                  --> println("Hello World!") 로 대체됨
        println(Foo.bar)                --> println("bar")          로 대체됨
        println(hello)
        println(Foo.bar)
    }

92. lateinit : 프로퍼티의 초기화를 보류(유예)

    class Point(val x:Int, val y:Int)
    class Rect{
        lateinit var pt:Point                   --> lateinit 은 var 앞에만 가능
        lateinit var pt2:Point

        val width: Int get()=pt2.x-pt.x
        val height: Int get()=pt2.y-pt.y
        val area get()=width*height
    }
    fun main() {
        val rect=Rect()
        rect.pt= Point(3,3)
        rect.pt2=Point(6,5)
        println("너비: ${rect.width}")            --> pt 와 pt2 에 값을 지정하지 않은 채 접근하면 UninitializedPropertyAccessException 발생
        println("높이: ${rect.height}")
        println("넓이: ${rect.area}")             --> lateinit 프로퍼티 초기화 확인 방법
    }                                                if(rect::pt.isInitialized){}

93. Nullable 리시버 : 확장 함수를 응용하여 참조 변수에 Null 이 지정되어 있어도 함수 호출 가능하게 함

    fun String?.isNumber(){                 --> 확장 함수 리시버 타입에 붙은 ? 이 Nullable 리시버
        if(this==null)
            println("문자열이 null 입니다")
    }
    fun main() {
        val empty:String? = null
        empty.isNumber()
    }

94. 동반자 객체의 확장 함수 : fun 클래스 이름.Companion.함수 이름() {}

    class Person{
        companion object                        --> 동반자 객체에 확장 함수를 주입하기 위해 빈 동반자 객체 정의
    }
    fun Person.Companion.create()=Person()      --> 동반자 객체에 create 함수 주입
    fun main() {
        Person.create()                         --> Person 클래스의 동반자 객체에 주입된 create 함수 호출
    }

95. 확장 함수의 리시버 타입이 상속 관계에 있을 때

    open class AAA
    class BBB: AAA()

    fun AAA.hello()=println("AAA")
    fun BBB.hello()=println("BBB")
    fun main() {
        val test: AAA=BBB()         --> AAA 타입이지만 실제로는 BBB 를 받고 있는 test 참조 변수
        test.hello()                --> test 가 BBB 를 받고 있어 BBB.hello 가 호출될 것 같지만 실제로는 AAA.hello() 가 호출
    }                                   확장 함수는 멤버 함수와는 다르게 참조 변수가 실제로 가리키는 객체의 타입을 따르지 않고,
                                        참조 변수의 타입을 그대로 따른다.

96. 추상 클래스(Abstract Class) :

    abstract class Person{                                      --> abstract 는 자체로 open 포함하고 있음
        abstract fun getSalary(): Int                           --> 추상 멤버 함수. 추상 프로퍼티도 가질 수 있음
    }
    class Student(private val tuition:Int): Person(){
        override fun getSalary()=-tuition                       --> 추상 클래스 상속 시, 추상 멤버 함수 오버라이딩 필수
    }
    class Professor(private val classCount: Int): Person(){     --> 추상 클래스를 상속하는 서브 클래스도 abstract 붙이면 추상 함수를 반드시
        override fun getSalary()=classCount*200                     오버라이딩 하지 않아도 됨. 그러나 이 클래스를 다시 일반 클래스로 상속하려면
    }                                                               오버라이딩 필수
    class Employee(private val initial:Int, private val years:Int): Person(){
        override fun getSalary()=initial*(1.0+years/10.0).toInt()
    }
    fun getFinance(vararg persons: Person): Int{
        var i=0
        var finance=0
        while(i<persons.size){
            finance-=persons[i].getSalary()
            i+=1
        }
        return finance
    }
    fun main() {
        val finance = getFinance(Student(330),Student(330),Professor(1),Professor(2),Employee(1300,2))
        println("학교 재정: %finance 만원")               ㄴ getFinance() 함수의 persons 는 Person 타입이지만
    }                                                     실제 가리키고 있는 객체의 멤버 함수가 호출되므로 각 객체의 getSalary()가 호출됨

97. 인터페이스(Interface) : 클래스에 어떤 멤버 함수와 프로퍼티가 반드시 존재한다는 것을 보장하기 위한 장치

    interface Printable{
        fun print(): Unit                   --> 인터페이스의 멤버 함수는 내용이 비어 있으면 자동으로 abstract 가 붙음
    }
    class AAA: Printable{                   --> 인터페이스는 생성자가 존재하지 않으므로 상속할 때 () 붙이지 않음
        override fun print() {
            println("hello")
        }
    }
    fun print(anything: Printable){
        anything.print()                    --> Printable 타입을 받는 매개변수이므로 print()가 있다는 것을 항상 보장
    }
    fun main() {
        print(AAA())
    }

98. 다이아몬드 문제(Diamond Problem) : 인터페이스를 여러 개 상속할 때 발생할 수 있는 문제

    interface Parent {
        fun follow(): Unit
    }
    interface Mother: Parent{
        override fun follow() = println("follow his mother")
    }
    interface Father: Parent{
        override fun follow() = println("follow his fother")
    }
    class Child: Mother, Father{
        override fun follow() {
            println("A child decided to")
            super<Mother>.follow()                  --> <> 로 호출할 super 멤버 함수 지정
        }
    }
    fun main() {
        Child().follow()                            --> Child 의 인스턴스를 생성하고 곧바로 follow 멤버 함수 호출
    }

99. 중첩 클래스(Nested Class) : 클래스 안에 또 다른 클래스 선언. 중첩 클래스는 타입 이름이 바깥 클래스.중첩 클래스 로 만들어진다. 생성자도 마찬가지

    class Outer{
        class Nested{
            fun hello()=println("중첩된 클래스")
        }
    }
    fun main() {
        val instance: Outer.Nested = Outer.Nested()
        instance.hello()
    }

    ---------
    class Outer{
        private val property:Int=16
        class Nested{
            fun hello()=println(property) --> 오류 나옴(알 수 없는 참조 : property)
        }                                     중첩 클래스는 클래스 식별자만 바깥 클래스에 속해있을 뿐, 실제로는 완전히 분리되어 있음
    }                                         바깥과 중첩은 서로 어떠한 프로퍼티나 멤버 함수도 공유하지 않는다.

100. 내부 클래스(Inner Class) : 중첩 클래스와는 다르게, 내부 클래스는 인스턴스가 바깥 클래스의 인스턴스에 완전히 소속됨

    class Outer(private val value:Int){
        fun print(){
            println(this.value)
        }
        inner class Inner(private val innerValue:Int){
            fun print(){
                this@Outer.print()                          --> this@Outer 는 내부 클래스가 속해 있는 바깥 클래스의 인스턴스를 가리키는 참조 변수
                println(this.innerValue+this@Outer.value)
            }
        }
    }
    fun main() {
        val instance: Outer = Outer(610)                    --> Outer 인스턴스 생성
        val innerInstance: Outer.Inner = instance.Inner(40) --> Outer.Inner 인스턴스 생성. 참조 변수.생성자() 로 생성 가능
        innerInstance.print()                                   내부 클래스는 바깥 클래스의 인스턴스로부터만 생성할 수 있기 때문
    }

101. 데이터 클래스(Data Class) : 클래스에는 데이터 자체의 역할만 하는 클래스와 데이터를 다루는 역할을 하는 클래스가 있음
                               사원 데이터 자체만 가진 Employee 클래스와 Employee 의 인스턴스를 관리하는 EmployeeManager 클래스 처럼.
                               데이터 클래스로 선언하면 -> Any 클래스에 있는 equals, hashCode, toString 멤버 함수가 자동으로 오버라이딩
                                                       직접 선언하여 오버라이딩 할 수도 있음
                                                       equals : 각 프로퍼티의 값이 서로 모두 같으면 true, 하나라도 다르면 false
                                                       toString : "Employee(name=...,age=...,salary=...)" 형태로 오버라이딩
                                                       copy() 함수가 자동으로 선언됨.

                               데이터 클래스의 규칙 - 1) 적어도 하나의 프로퍼티
                                                   2) 생성자 매개변수에 반드시 val 혹은 var 붙여줘야함. 프로퍼티에 대응하지 않는 생성자 매개변수 불가
                                                   3) abstract, open, sealed, inner 불가
                                                   4) 인터페이스만 구현할 수 있음. (코틀린 1.1 이후로는 sealed 클래스도 상속 가능)
                                                   5) component1, component2 같은 이름으로 멤버 함수 선언 불가. 컴파일러가 사용하는 이름

    data class Employee(val name:String, val age:Int, val salary:Int)

    fun main() {
        val first=Employee("John",30,3000)
        val second=Employee("Page",24,5400)
        val third=first.copy()                  --> 모든 매개 변수가 디폴트 인수를 갖고 있으므로, first.copy(name="Jang") 형식으로
                                                    원하는 프로퍼티만 다른 값으로 지정한 채 복사 가능
        println(first.toString())
        println(third.toString())
        println(first==second)
        println(first==third)
    }

102. 객체 분해하기 : 데이터 클래스의 인스턴스에 한해 객체를 여러 개의 변수로 쪼갤 수 있음

    data class Employee(val name:String, val age:Int, val salary:Int)

    fun main() {
        val(name,_,salary)=Employee("John",30,3000)
        val(_,age,_)=Employee("John",30,3000)
        println(name)
        println(salary)
        println(age)
    }

103. 함수 리터럴(Function Literal)과 람다식(Lambda Expression)

    fun main() {
        val instantFunc:(Int)->Unit                            -->(Int)->Unit 은 Int 타입이고 반환 타입이 Unit 인 함수를 저장할 수 있는 타입(함수 타입)
        instantFunc={number:Int -> println("Hello$number")}    --> 이 부분이 함수 리터럴(함수를 나타내는 리터럴). number:Int 는 매개 변수
        instantFunc(33)                                            -> 를 경계로 매개 변수와 함수의 내용이 분리. 함수 리터럴에는 return 적지 않는다.
        instantFunc.invoke(33)                                 --> invoke 통해서도 호출 가능. 일반적으론 ()면 되지만 변수가 Nullable 일 경우
    }                                                              invoke 를 통해야 instantFunc?.invoke(33) 처럼 활용이 가능

104. 익명 함수(Anonymous Function) : 함수 리터럴의 또 다른 방식

    fun main() {
        val instantFunc:(Int)->Unit=fun(number:Int):Unit{  --> 익명 함수에는 inline 같은 키워드 불가
            println("Hello$number")
        }
        instantFunc(33)
        instantFunc.invoke(33)
    }

105. it 식별자 : 람다식의 매개 변수가 하나일 때는 매개 변수 선언을 생략할 수 있음

    fun main() {
        val instantFunc:(Int)->Unit={     --> (Int) 타입의 매개 변수를 적어줘야 하지만 생략.
            println("Hello$it")           --> it 이 생략된 매개 변수를 대신함
        }
        instantFunc(33)
    }

106. 함수 참조(Function Reference) : 함수 타입의 변수는 이미 선언되어 있는 함수나 객체의 멤버 함수를 가리킬 수 있음

    fun plus(a:Int,b:Int)=println("plus 호출됨${a+b}")
    object Object{
        fun minus(a:Int, b: Int)=println("Object 의 minus 호출됨${a-b}")
    }
    class Class{
        fun average(a: Int,b: Int)=println("Class 의 average 호출됨${(a+b)/2}")
    }

    fun main() {
        var instantFunc:(Int, Int)->Unit            --> (Int, Int)->Unit 타입의 instantFunc 함수 타입 참조 변수
        instantFunc=::plus
        instantFunc(60,27)

        instantFunc=Object::minus
        instantFunc(36,12)

        instantFunc=Class()::average
        instantFunc(25,15)
    }

107. 고차 함수(Higher-order Function) : 함수 리터럴은 보통 고차 함수를 위해 사용. 고차 함수란, 인수로 함수를 받거나 함수를 반환하는 함수
                                      고차 함수의 마지막 매개 변수 타입이 함수 타입이면 () 생략 가능
                                      매개 변수가 여러 개이고, 함수 타입의 매개 변수가 마지막으로 온다면 일반 인수들은 소괄호로 감싸고
                                      함수 리터럴은 바깥으로 뺄 수 있음.
                                      decorate(인수1, 인수2){ ... }

    fun decorate(task:()->Unit){            --> ()->Unit 타입의 함수를 받는 매개 변수 task
        println("===작업 시작===")
        task()                              --> task 매개 변수가 가리키는 함수 호출
        println("===작업 종료===")
    }
    fun main() {
        decorate {
            val a=10
            val b=5
            println("$a+$b=${a+b}")
        }
        decorate {
            println("some")
            println("tasks")
        }
    }

108. 클로저(Closure) : 지역 변수는 자신이 소속된 블록이 끝나면 소멸하지만, 클로저를 이용하면 소멸하지 않는 것처럼 보이게 할 수 있음

    fun returnFunc(num:Int):()->Unit={println(num)}
    fun main() {
        val f:()->Unit=returnFunc(30)       --> returnFunc 함수가 반환한 함수({println(num)})를 f 에 저장
        f()                                 --> f 를 호출하면 println(num) 수행
    }                                           원래는 returnFunc 함수가 호출된 순간 num 지역 변수는 소멸해야함.
                                                하지만 main 함수 블록에서 함수 리터럴이 만들어지는 순간, 리터럴은 주변의 상황을 함께 저장
                                                즉, 함수가 만들어질 때 num 매개 변수의 값을 복사해서 가지고 있음. 이게 클로저(Closure)

109. 리시버가 붙은 함수 리터럴 : 확장 함수처럼 만들 수 있음

    fun main() {
        val makeSure:Int.(left:Int, right:Int)->Int
        makeSure={
            left:Int, right:Int ->
            if(this<left) left                  --> 리시버를 가리키는 this. 여기서 this = Int.
            else if(this>right) right
            else this
        }
        println(15.makeSure(20,40))             --> this = 15
        println(18.makeSure(0,50))              --> this = 18
        println(25.makeSure(0,19))              --> this = 25
    }

    %% Int.(Int,Int)-> 타입은 (Int,Int,Int)->Int 타입에 대입할 수 있음
       val makeSure:Int.(left:Int, right:Int)->Int
       makeSure2:(Int,Int,Int)->Int = makeSure
       makeSure2(15,20,40) == 15.makeSure(20,40) -> 일반 함수 타입으로 호출할 때는 리시버를 첫 번째 인수로 전달

110. 제네릭(Generic) : 인수를 전달하듯이 함수에 타입 전달 가능

    fun <T> toFunction(value:T):()->T = { value }       --> <식별자> 부분을 타입 매개 변수라고 함.
    fun main() {
        val func:() -> Int = toFunction<Int>(1107)      --> 제네릭이 적용된 함수를 호출하려면 함수 이름 옆에 <타입 이름>. 타입 이름 = 타입 인수
        println(func())                                     타입 인수를 지정하면, T 가 Int 로 모두 치환됨. 여기서는 1107이 Int 타입인 것을
    }                                                       추론 가능하므로 <Int> 생략해도 무방

111. 여러 타입을 인수로 받기

    fun< T,R> T.map(mapper:(T)->R):R{
        return mapper(this)
    }
    fun main() {
        val square:Int=11.map{it*it}
        println(square)
    }

112. 구체화된(Reified) 타입 매개 변수

    fun <T> check(){
        val number=0
        if(number is T)                     --> 오류 발생. 타입 매개 변수는 is 연산자의 피연산자로 사용할 수 없음
            println("T는 Int 타입 입니다.")
    }
    -------------------------------------
    inline fun <reified T> check(){         --> 타입 매개 변수에 reified 를 붙이려면 반드시 inline 선언
        val number=0
        if(number is T)                     --> 타입 매개 변수 앞에 reified 붙이면 is 연산자에 사용 가능
            println("T는 Int 타입 입니다.")
    }
    fun main() {
        check<Int>()
    }

113. 클래스와 인터페이스에서 제네릭 사용하기

    class Pair<A,B>(val first:A,val second:B){          --> 클래스나 인터페이스에서 타입을 인수로 받으려면 이름 옆에 <식별자>
        override fun toString()= "$first\n$second"
    }

    fun main() {
        val pair:Pair<Int,Double>
        pair=Pair<Int,Double>(15,9.12)                  --> 생성자 호출할 때도 이름 옆에 <타입 인수> 붙임
        println(pair.toString())                            생성자의 인수로부터 Int 와 Double 타입을 추론 가능하므로 <Int, Double> 생략 가능
    }

114. 제네릭이 적용된 클래스/인터페이스 상속, 구현하기

    interface Plusable<T> {
        operator fun plus(other:T):T
    }
    ---------
    class Rectangle(val width:Int, val height:Int):Plusable<Rectangle> {    --> Plusable 에는 제네릭이 적용, 타입 인수(Rectangle) 전달해야함
        override fun plus(other: Rectangle)= Rectangle(width+other.width,height+other.height)
                                                                --> Plusable 구현하면서 타입 인수로 Rectangle 전달했으므로 매개 변수와
                                                                    반환 타입을 Rectangle
        override fun toString()="width: $width, height: $height"
    }
    ---------
    fun main() {
        val rect=Rectangle(10,5)
        val rect2=Rectangle(3,8)
        println(rect+rect2)
    }

115. 특정 타입을 상속, 구현하는 타입만 인수로 받기 : 제네릭을 사용하다 보면 특정 타입에만 선언되어 있는 프로퍼티나 멤버 함수에 접근하기 위해
                                              특정 타입만 인수로 받아야 할 때가 있음

    interface ValueContainer{
        fun getValue():Int
    }
    class AAA:ValueContainer{
        override fun getValue(): Int =1102
    }
    class BBB:ValueContainer{
        override fun getValue(): Int =127
    }
    -------------
    fun<T:ValueContainer> T.printValue(){       --> 특정 타입을 구현하는 타입만 인수로 받으려면, 타입 매개 변수 뒤에 : 타입 이름 을 적어준다.
        println(this.getValue())                    : 타입 1, 타입2, ... 로 여러 개도 가능
    }
    fun main() {
        AAA().printValue()
        BBB().printValue()
    }

116. in/out 키워드

    class AAA<T>
    ...
        val a=AAA<Int>
        val b:AAA<Any>=a        --> 오류. Int 가 Any 를 상속하는 서브 타입이라고는 하지만 AAA<Int> 가 AAA<Any>의 서브 타입인 것은 아님

    ----------------------------------
    class AAA<out T>                    --> 타입 매개 변수 앞에 out 붙이면 AAA<서브 타입>을 AAA<슈퍼 타입>에 대입할 수 있음
                                            Java 의 ? extends T 와 같음
    class BBB<in T>                     --> 타입 매개 변수 앞에 in 붙이면 BBB<슈퍼 타입>을 BBB<서브 타입>에 대입할 수 있음
                                            Java 의 ? super T 와 같음
    fun main() {
        val aaaSub=AAA<Int>()
        val aaaSuper:AAA<Any> = aaaSub

        val bbbSuper=BBB<Any>()
        val bbbSub:BBB<Int> = bbbSuper

        val star:AAA<*> = aaaSub        --> 타입 인수로 *을 지정하면 타입 인수가 무엇이든 상관 없이 AAA 타입 대입 가능
    }

117. .. 연산자와 범위 표현식(Range Expression) : .. 연산자는 범위를 표현하는 연산자

    fun main() {
        val oneToTen:IntRange=1..10         --> .. 연산자는 operator fun rangeTo(매개 변수: 자유 타입):자유 타입 으로 오버로딩 가능
                                                Int 클래스 안에는 operator fun rangeTo(other:Int):IntRange 가 선언되어 있음
                                                즉, 1..10 은 1.rangeTo(10)으로 컴파일되며, IntRange 타입의 값이 반환
        println(5 in oneToTen)              --> IntRange 클래스는 contains 연산자 멤버 함수를 갖고 있기 때문에 in 연산자 사용 가능
                                                5가 1~10 정수 사이에 있는지 여부를 boolean 값으로 반환

        val upperAtoZ:CharRange='A'..'Z'    --> Char 클래스 안에는 operator fun rangeTo(other:Char):CharRange 가 선언되어 있음
        if('C' in upperAtoZ)                --> CharRange 클래스도 IntRange 클래스와 마찬가지
            println("대문자 입니다.")             문자를 유니코드로 변환 후 범위에 속해있는지 여부 확인 후 boolean 타입으로 반환
        if('p' in 'a'..'z')
            println("소문자 입니다.")
    }
                                            --> if(0<=num && num<=100) ---> if(num in 0..100) 표현 가능. 훨씬 간결함

118. 반복자(iterator) : 특정 구간 속에 있는 원소를 하나씩 반복적으로 꺼내기 위한 인터페이스를 뜻함.
                       코틀린에는 iterator 인터페이스가 기본적으로 구현되어 있음

                       interface Iterator<out T>{
                          operator fun next():T
                          operator fun hasNext(): Boolean
                       }
    -----------------------------------------------
    fun main() {
        val range: IntRange = 1..3                  --> IntRange 클래스에는 operator fun iterator(): IntIterator 연산자 멤버 함수 선언되어 있음
        val iter: Iterator<Int> = range.iterator()      IntIterator 는 Iterator<Int> 를 구현하는 클래스 이므로 Iterator<Int>로 받을 수 잇음음

        println(iter.hasNext())                      --> iter 는 1..3 구간 중 첫 원소인 1의 바로 이전(0??)을 가리키고 있음. 여기서
                                                         특정 원소를 가리키는 Iterator 내부의 변수를 커서(Cursor)라고 함.
                                                         iter.hasNext 는 다음 원소가 있으면 true, 없으면 false. 1을 가리킬 예정이므로 true 출력
        println(iter.next())                         --> 커서를 다음 원소인 1로 이동하고 1을 반환, 1을 출력

        println(iter.hasNext())                      --> true
        println(iter.next())                         --> 커서를 2로 이동, 2 반환, 2 출력

        println(iter.hasNext())                      --> true
        println(iter.next())                         --> 커서를 3으로 이동, 3 반환, 3 출력

        println(iter.hasNext())                      --> 더 이상 다음 원소가 없으므로 false 출력
    }                                                    hasNext 가 false 를 반환했는데도 next 호출하면 NoSuchElementException 예외 발생

119. 흐름 제어-반복문 for : for(변수 이름 : 타입 in 표현식 { ...}
                         코틀린의 for 문은 for-each 스타일만 지원
                         in 우측의 표현식에는 operator fun iterator():Iterator<자유 타입> 의 연산자 멤버 함수를 갖는 객체만 지정 가능
                         만약 for(변수 이름: Double in 표현식) 형태로 사용하려면, operator fun iterator():Iterator<Double> 형태의
                         연산자 멤버 함수를 갖고 있어야 함. 즉 for 문 속의 변수 타입과 Iterator 의 타입 인수가 같아야 함

    fun main() {
        for(i: Int in 1..10)        --> ..(IntRange 클래스)에는 Iterator<Int> 타입을 반환하는 iterator 연산자 멤버 함수가 선언되어 있으므로 적용 가능
            print("$i")
        println()

        for(i: Int in 1..10){
            if(i>5)
                break
            print("$i")
        }
    }

120. 배열(Array) : 타입이 같은 변수를 여러개 만들 때 사용
                  class Array<T>{
                      val size: Int
                      operator fun get(index:Int):T             --> get, set 멤버 함수는 배열을 [] 연산자로 접근 가능하게 해줌
                      operator fun set(index:Int, value:T):Unit
                      operator fun iterator():Iterator<T>       --> iterator 연산자 멤버 함수는 배열을 for 문에 사용 가능하게 해줌
                  }

    fun main() {
        val integers: Array<Int> = arrayOf(10, 20, 30, 40)    --> 힙 영역에 10~40 생성성

        println(integers.size)
        println(integers[])

        for (i in integers)
            print("$i ")
   }

121. 배열을 가변 인수로 활용하기

    fun printAll(vararg tokens:String){
        for(token in tokens)
            print("$token")
    }
    fun main() {
        val numbers:Array<String> = arrayOf("What's","your","name?")
        printAll(*numbers)                                              --> 배열 앞에 * 을 찍으면 배열 내용을 가변 인수로 활용 가능
    }

122. 열거 클래스(Enum Class)

    enum class Mode{
        SELECTION, PEN, SHAPE, ERASER               --> 열거 클래스 안에 들어가는 식별자를 열거 상수라고 함
    }

    fun main() {
        // 현재 선택된 모드
        val mode: Mode=Mode.PEN                     --> Mode 타입의 변수는 열거 클래스.열거 상수 형태로 초기화

        when(mode){
            Mode.SELECTION -> println("선택 모드")
            Mode.PEN -> println("펜 모드")
            Mode.SHAPE -> println("도형 모드")
            Mode.ERASER -> println("지우개 모드")
        }
    }

123. 열거 클래스에 프로퍼티와 멤버 함수 선언하기

    enum class Mode(val number:Int){
        SELECTION(0), PEN(1), SHAPE(2), ERASER(3);      --> 열거 클래스에 생성자가 있으면, 열거 상수에도 각각 인수를 적어서 생성자 호출해야 함
                                                            마지막 열거 상수 끝에는 ; 반드시 붙여줘야 함
        fun printNumber(){                              --> 열거 클래스의 멤버 함수나 프로퍼티는 반드시 상수 나열 후에 선언해야 함
            println("모드: $number")
        }
    }

    fun main() {
        // 현재 선택된 모드
        val mode: Mode=Mode.ERASER
        println(mode.number)
        mode.printNumber()
    }

124. 열거 클래스 활용하기 : 모든 열거 클래스는 자동으로 Enum 클래스 상속.
                        Enum 클래스 안에는 val name: String; val ordinal: Int 멤버가 있음
                        fun valueOf(value:String):열거 클래스
                        fun values():Array<열거 클래스>
                        함수도 기본 포함

    enum class Mode{
        SELECTION, PEN, SHAPE, ERASER;
    }

    fun main() {
        val shapeMode:Mode=Mode.SHAPE
        println(shapeMode.name)                 --> Enum 클래스 안에 name(상수 이름) 과 ordinal(상수 순서)이
        println(shapeMode.ordinal)                  기본적으로 있기 때문에 name, ordinal 호출 가능

        val modes:Array<Mode> =Mode.values()    --> values() 는 열거 클래스의 열거 상수들을 배열로 반환
        for(mode: Mode in modes)
            println(mode)

        println(Mode.valueOf("PEN").ordinal)    --> valueOf() 멤버 함수는 열거 상수의 이름으로부터 열거 상수를 찾아 반환
    }

125. sealed 클래스 : 자신의 중첩 클래스에만 상속을 허용하는 클래스
                    1.1 버전 이후로는 sealed 클래스와 같은 파일에 속해 있기만 해도 sealed 클래스 상속 가능

    sealed class Outer{
        class One:Outer()
        class Two:Outer()
        class Three:Outer()
    }
    class Four: Outer()         --> 같은 파일 내라면 중첩 클래스가 아니라도 상속 가능
    ------------------------
    class Four: Outer()         --> 오류. sealed 클래스는 자신의 중첩 클래스 혹은 같은 파일 내에서만 상속 가능
    ------------------------
    fun main() {
        val instance: Outer=Outer.Three()

        val text: String = when(instance){      --> instance 의 실제 타입을 판별하여(is 연산자) 대응하는 String 리터럴로 반환
            is Outer.One -> "첫 번쨰"                sealed 클래스는 서브 클래스가 sealed 클래스 안에 모두 존재하므로,
            is Outer.Two -> "두 번쨰"                모든 서브 타입을 체크했다면 when 의 else 블록을 생략해도 표현식 구성 가능
            is Outer.Three -> "세 번쨰"
        }
        println(text)
    }

126. 위임된 프로퍼티(Delegated Property) : 프로퍼티의 getter/setter 구현을 다른 객체에 맡기는 방법
                                        Int 타입의 프로퍼티에 음수가 저장되는 것을 방지하는 Setter
                                        val age:(Int) set(value) if(value>=) field=value

    class Sample {
        var number:Int by OnlyPositive()        --> by 객체 를 적으면 해당 객체가 프로퍼티의 getter/setter 대신함
    }
    ------------------------------------
    import kotlin.reflect.KProperty

    class OnlyPositive{
        private var realValue: Int = 0
        operator fun getValue(thisRef:Any?,property:KProperty<*>):Int{          --> 프로퍼티를 대리하는 객체는 getValue 와 setValue
            return realValue                                                        멤버 함수를 갖고 있어야함(써있는 그대로)
        }                                                                           :Int 는 원래 :T 이고, T는 대리할 프로퍼티의 타입
        operator fun setValue(thisRef:Any?,property:KProperty<*>, value:Int) {
            realValue = if (value > 0) value else 0
        }
    }
    -------------------------------------
    fun main() {
        val sample = Sample()

        sample.number = -50                 --> OnlyPositive 의 setValue 호출
        println(sample.number)              --> OnlyPositive 의 getValue 호출

        sample.number = 100
        println(sample.number)
    }

127. 클래스 위임(Class Delegation) : 인터페이스의 구현을 다른 클래스에 맡길 수 있는 문법

    interface Plusable {
        operator fun plus(other:Int):Int        --> Int 타입과 덧셈을 가능하게 하는 인터페이스 선언
    }
    -------------------------------------
    class ClassDelegator:Plusable{              --> Plusable 구현하는 클래스
        override fun plus(other: Int): Int {
            println("기본 구현")
            return other
        }
    }
    -------------------------------------
    class Sample:Plusable by ClassDelegator()   --> 인터페이스 구현하면서 by 객체 지정하면 인터페이스 구현을 해당 객체로 위임
                                                    Sample 의 plus 연산자를 호출하면 ClassDelegator 의 plus 가 호출
    -------------------------------------
    fun main() {
        println(Sample()+10)                    --> ClassDelegator 의 plus 가 호출
    }

128. Pair 클래스: 두 변수를 하나로 묶기 : data class Pair<out A, out B>(val first:A, val second:B): Serializable
                                     Pair 클래스는 제네릭을 이용하여 두 가지 타입의 값을 보관한다

    fun divide(a:Int, b:Int): Pair<Int,Int> = Pair(a/b,a%b)     --> divide 의 반환 타입이 Pair<Int,Int>
    fun main() {
        val(q,r) = divide(10,3)                                 --> Pair 클래스는 데이터 클래스이므로 변수 쪼개기가 가능
        println("몫: $q")
        println("나머지: $r")
    }

129. to 확장 함수: 두 값을 간단히 Pair 로 묶기 : infix fun <A,B> A.to(that:B): Pair<A,B> = Pair(this,that)
                                            to 는 모든 타입에 적용되는 확장 함수.
                                            리시버 타입에 제네릭을 적용했기 때문. 내부적으로 Pair 생성자를 호출하여 Pair 객체 생성한 뒤 반환

    fun main() {
        val test:Pair<Int,Double> = 10 to 3.14      --> to 확장 함수는 infix 로 선언되어 있기 때문에 연산자처럼 사용 가능
    }

130. Triple 클래스 : 세 변수를 하나로 묶기 : data class Triple<out A, out B, out C>(val first:A, val second:B, val third:C):Serializable
                                        Triple 클래스는 제네릭을 이용하여 세 가지 타입의 값을 보관

    fun calculateCircle(radius: Int): Triple<Int, Double, Double> =
            Triple(radius*2, radius*2*3.14, 3.14*radius*radius)
    fun main() {
        val(diameter, _, area) = calculateCircle(5)                     --> Triple 클래스는 데이터 클래스이므로 여러 변수로 분해할 수 있고
        println("지름 : $diameter")                                          사용하지 않을 값은 _ 로 무시함
        println("넓이 : $area")
    }

131. Comparable 인터페이스: 클래스를 비교 가능하게 만들기 : interface Comparable<in T>{
                                                        operator fun compareTo(other: T): Int
                                                     }
                                                     타입 매개 변수 T를 받으며, 연산자 멤버 함수로 compareTo 를 갖고 있으므로 비교 연산자 지원함
                                                     operator fun <T:Comparable<T>> T.rangeTo(that:T): ClosedRange<T>
                                                     라는 연산자 확장 함수도 기본 선언되어 있기 때문에 .. Comparable 인터페이스를
                                                     구현하는 모든 클래스는 .. 연산자를 지원

     class Rectangle(val width:Int, val height:Int):Comparable<Rectangle>{
         val area = width*height

         override fun compareTo(other:Rectangle):Int=
                 when{
                     this.area > other.area -> 1
                     this.area < other.area -> -1
                     else -> 0
                 }
     }
     fun main() {
         val rect = Rectangle(3,5)
         val rect2 = Rectangle(7,3)
         val rect3 = Rectangle(2,9)

         println(rect2 >= rect3)
         println(rect < rect2)
         println(rect2 > rect3)
     }

132. ClosedRange 인터페이스: 닫힌 구간을 표현하는 인터페이스

     interface ClosedRange<T:Comparable<T>>{        --> 타입 매개 변수로 Comparable<T> 타입만 받는다. 대소 비교가 가능해야 범위 형성이 가능
        val start:T                                 --> 구간의 최솟값
        val endInclusive:T                          --> 구간의 최댓값
        operator fun contains(value:T):Boolean = value >= start && value <= endInclusive    --> contains 는 in 연산자 지원
        fun isEmpty(): Boolean = start > endInclusive                                       --> 구간이 비어 있는지 여부 반환
     }
     --------------------------------------------------------

    fun main() {
        val intRange:IntRange = 1..10
        val longRange:LongRange = 1L..100L
        val charRange:CharRange = 'A'..'Z'

        println(intRange.start)
        println(longRange.endInclusive)
        println('*' in charRange)
        println(charRange.isEmpty())
    }

    %% 실수 타입의 Range 클래스(ClosedFloatRange, ClosedDoubleRange)를 1.1 부터 제공은 하지만 for 문의 in 연산자에 사용 불가
       iterator 연산자 멤버 함수를 갖고 있지 않기 때문.
    %% ClosedRange 를 리시버로 하는 contains 연산자 확장 함수가 선언되어 있으므로 in 연산자 오른쪽 피연산자에 사용 가능

133. Iterable 인터페이스: 클래스가 반복자를 지원하도록 하기

    interface Iterable<out T>{
        operator fun iterator(): Iterator<T>
    }
    %% IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> 구현
       Long, Char 도 마찬가지로 해당 인터페이스(-Progression, ClosedRange<T> 구현하고 있음)
       각 -Progression 은 Iterable<-> 를 상속하고, 덕분에 for 문의 in 연산자에 사용 가능
       각 -Progression 은 아래 프로퍼티가 있음
            open class --Progression{
                val first:Int               --> --Progression 의 시작 값과 끝 값을 가리키는 프로퍼티
                val last:Int
                val step:Int                --> 반복자(Iterator<T>)의 next 를 호출할 때 몇 칸씩 건너뛸지 나타내는 프로퍼티
            }
    -------------------------------------------
    fun main() {
        val prog:IntProgression = 3..7
        println(prog.first)
        println(prog.last)
        println(prog.step)

        for(i in prog)
            print("$i")             --> IntProgression 은 for 문의 in 에는 사용 가능하지만 그냥 in 연산자에는 불가(contains 연산자 멤버 함수가 없음)
    }

134. Progression 과 관련된 함수 : 확장 함수를 이용하면 Progression 타입을 제대로 활용할 수 있음

    fun IntProgression.print(){
        print("first: ${this.first},")
        print("last: ${this.last},")
        println("step: ${this.step}")

        for(i in this)
            print("$i")
        println('\n')
    }
    fun main() {
        val prog:IntProgression = 7 downTo 3
        prog.print()

        val prog2:IntProgression = (3..7).reversed()
        println(prog==prog2)
        prog2.print()

        val prog3:IntProgression = (1..10) step 3
        prog3.print()

        val prog4:IntProgression = 10 downTo 2 step 3
        prog4.print()

        val prog5:IntProgression = 2 until 5
        prog5.print()
    }

135. 코틀린의 컬렉션(Collection) : 프로그램을 개발하는데 필요한 기본적인 자료구조들의 통칭
                                List -> 순서가 있는 목록을 표현하는 자료구조
                                Set  -> 집합을 표현. 중복 비허용, 순서 없음
                                Map  -> 연관 배열을 표현. 키와 값을 1:1 대응. 키는 중복 불가

            Collection<E>               Map<K,V>
           /          \                     |
          /   상속 관계  \               독자적인 멤버
     List<E>          Set<E>

    fun main() {
        val list:Collection<Int> = listOf(10,20,10)
        val set:Collection<Int> = setOf(1,2,3,2,3)
        val map:Map<String,String> = mapOf("Appple" to "사과","Banana" to "바나나")

        println(list)
        println(set)
        println(map)
    }

136. Collection 인터페이스 살펴보기 :

        interface Collection<out E>: Iterable<E>{
            abstract val size:Int                                       --> 콜렉션에 포함된 원소의 개수
            abstract fun isEmpty(): Boolean                             --> 콜렉션 비어있는지 여부
            abstract operator fun contains(element: E): Boolean         --> element 원소가 콜렉션에 포함되는지 여부 반환하는 연산자 멤버 함수
            abstract fun containsAll(elements: Collection<E>): Boolean   --> elements 원소들이 콜렉션에 모두 포함되는지 여부 반환하는 연산자 멤버 함수
            abstract fun iterator(): Iterator<E>                         --> 콜렉션의 각 원소를 순회하는 Iterator<E> 타입의 객체를 반환하는
        }                                                                   연산자 멤버 함수. 콜렉션을 for 의 in 에 사용 가능하게 해줌
    ---------------------------------------------------------
    fun main() {
        val list:Collection<Int> = listOf(18,1,1,4)

        println(list.size)
        println(list.isEmpty())
        println(18 in list)

        for(i: Int in list)
            print("$i")
    }

137. List 인터페이스 살펴보기 :

    interface List<out E> : Collection<E> {
        operator fun get(index: Int): E                     --> index 번째 원소 반환. List 에 [] 연산자 쓸 수 있도록 하는 역할
        fun indexOf(element: @UnsafeVariance E): Int        --> element 가 몇 번째 인덱스에 있는지 반환. 없으면 -1, 여러 개면 첫 번쨰
        fun lastIndexOf(element: @UnsafeVariance E): Int    --> 마지막으로 일치하는 원소의 인덱스
        fun listIterator(): ListIterator<E>                 --> index 매개 변수에 값을 지정하면, 그 인덱스부터 시작하는 ListIterator 반환
        fun listIterator(index: Int): ListIterator<E>       --> index 매개 변수에 값을 지정하면, 그 인덱스부터 시작하는 ListIterator 반환
        fun subList(fromIndex: Int, toIndex: Int): List<E>  --> from ~ to 구간의 원소를 뽑아 새로운 리스트 반환
    }
    -------------------------------
    fun main() {
        val list:List<Double> = listOf(20.18,1.14,9.15,1.14)

        println(list[0])
        println(list.indexOf(1.14))
        println(list.indexOf(9.31))
        println(list.lastIndexOf(1.14))
        println(list.subList(0,3))
    }

138. ListIterator 인터페이스 살펴보기 :

    interface ListIterator<out T> : Iterator<T> {
        fun hasPrevious(): Boolean      --> 이전 원소가 존재하는지 여부 반환
        fun previous(): T               --> 이전 원소를 반환하고, ListIterator 의 커서를 뒤로 한 칸
        fun nextIndex(): Int            --> 다음 원소의 인덱스 반환. 커서 미이동
        fun previousIndex(): Int        --> 이전 원소의 인덱스 반환. 커서 미이동
    }
    -----------------------------------------
    private fun moveToNext(iter:ListIterator<Int>){
        print("${iter.hasPrevious()},")
        print("${iter.hasNext()},")
        print("${iter.previousIndex()},")
        print("${iter.nextIndex()},")
        println("${iter.next()}")
    }
    fun main() {
        val iter: ListIterator<Int> = listOf(10,20,30).listIterator()

        moveToNext(iter)        --> 0번째 원소 가리킬 예정
        moveToNext(iter)        --> 1번째 원소 가리킬 예정
        moveToNext(iter)        --> 2번째 원소 가리킬 예정
    }

139. Map 인터페이스 살펴보기 :

    interface Map<K, out V> {
        public val size: Int                                                --> Map 에 들어 있는 키와 값 쌍의 갯수
        public fun isEmpty(): Boolean                                       --> Map 이 비어있는지 여부 반환
        public fun containsKey(key: K): Boolean                             --> Map 의 key 에 해당하는 키가 있는지 여부 반환
        public fun containsValue(value: @UnsafeVariance V): Boolean         --> Map 의 value 에 해당하는 값이 있는지 여부 반환
        public operator fun get(key: K): V?                                 --> key 에 해당하는 값을 반환하는 연산자 멤버 함수. 없으면 null
        public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V --> key 에 해당하는 값을 반환하되, 없으면 defaulValue 대신 반환
        public val keys: Set<K>                                             --> Map 의 키들만 갖는 프로퍼티. set 타입(중복 불가)
        public val values: Collection<V>                                    --> Map 의 값들만 갖는 프로퍼티. 값은 중복 가능하므로 Collection 타입
        public val entries: Set<Map.Entry<K, V>>                            --> Map 에 있는 모든 키와 값 쌍들을 갖는 프로퍼티
        interface Entry<out K, out V>{}                                     --> 키와 한 쌍은 표현하는 중첩 인터페이스
    }
    ------------------------------------------------

    fun main() {
        val map:Map<String, String> = mapOf("Apple" to "사과", "Banana" to "바나나")

        println(map.size)
        println(map.keys)
        println(map.values)
        println(map.entries)
        println(map.isEmpty())
        println(map.containsKey("Cocoa"))
        println(map.containsValue("바나나"))
        println(map["Apple"])
        println(map.getOrDefault("Cocoa", "코코아"))       --> "Cocoa"에 해당하는 값이 없으므로 코코아 출력
    }

140. 변경할 수 있는(Mutable) 콜렉션 : Collection, List, Map 인터페이스는 원소를 추가하거나 삭제하는 방법을 제공하지 않음

    interface MutableCollection<E> : Collection<E>, MutableIterable<E> {
        override fun iterator(): MutableIterator<E>             --> Iterable 인터페이스의 iterator() 함수 오버라이딩해서
                                                                    반환 타입을 MutableIterator 타입으로 변환
        public fun add(element: E): Boolean                     --> 콜렉션에 element 추가. 성공하면 true 반환
        public fun remove(element: E): Boolean                  --> 콜렉션에서 element 삭제. 성공하면 true 반환. 원소 없으면 false
        public fun addAll(elements: Collection<E>): Boolean     --> elements 콜렉션의 모든 원소를 콜렉션에 추가. 하나라도 추가되면 true
        public fun removeAll(elements: Collection<E>): Boolean  --> elements 콜렉션의 원소들과 일치하는 모든 원소 제거. 하나라도 제거되면 true
        public fun retainAll(elements: Collection<E>): Boolean  --> elements 콜렉션의 원소와 일치하는 원소만 남기고 모두 제거. 하나라도 제거되면 true
        public fun clear(): Unit                                --> 콜렉션의 모든 원소 삭제
    }
    -------------------------------------------------
    fun main() {
        val mutableList:MutableCollection<Int> = mutableListOf(1,2,4,2,3,2,5)
        println(mutableList)

        mutableList.add(1)
        println(mutableList)

        mutableList.addAll(listOf(3,2,4))
        println(mutableList)

        mutableList.remove(1)
        println(mutableList)

        mutableList.removeAll(listOf(1,2))
        println(mutableList)

        mutableList.retainAll(listOf(3,5))
        println(mutableList)

        mutableList.clear()
        println(mutableList)
    }

    %% 콜렉션을 반드시 수정해야 하는 상황이 아니라면 일반 Collection 사용을 권장. 콜렉션 수정이 가능하다면,
       콜렉션의 원소가 관련된 오류가 발생했을 때 어느 지점에서 콜렉션 수정이 일어나는지 하나하나 찾아봐야 함

141. MutableIterator 인터페이스 살펴보기

    interface MutableIterator{
        public fun remove(): Unit       --> 커서가 가리키고 있는 원소 삭제
    }
    --------------------------------
    fun main() {
        val list = mutableListOf(1,2,3)
        val iter: MutableIterator<Int> = list.iterator()
        println(list)

        iter.next()             --> 커서를 1로 옮김
        iter.remove()           --> 1 삭제
        println(list)

        iter.next()             --> 커서를 하나 더 옮김(2로)
        iter.remove()           --> 2 삭제
        println(list)           --> [3]
    }

142. MutableList 인터페이스 살펴보기
    interface MutableList{
        fun add(element: E): Boolean
        fun remove(element: E): Boolean
        fun addAll(index: Int, elements: Collection<E>): Boolean    --> index 위치에 elements 원소 전부 추가
        operator fun set(index: Int, element: E): E                 --> [] 연산자를 오버로딩. index 위치의 원소를 element 로 교체
        public fun removeAt(index: Int): E                          --> index 위치의 원소 삭제
    }
    ---------------------------------------------
    fun main() {
        val list:MutableList<Char> = mutableListOf('c','a','z')
        println(list)

        list.add('b')
        println(list)

        list.addAll(2,listOf<Char>('g','d','i'))
        println(list)

        list.removeAt(3)
        println(list)

        list.set(0,'p')
        println(list)
    }

143. MutableListIterator 인터페이스 살펴보기 : ListIterator<T>, MutableIterator<T> 를 구현함
                                           추가된 멤버 함수 -> abstract fun set(element:T):Unit 커서 위치 element 교체
                                                        -> abstract fun add(element:T):Unit 커서 위치에 element 추가

    fun main() {
        val list= mutableListOf<Int>(1,2,3)
        val iter:MutableListIterator<Int> = list.listIterator()

        println(list)
        println(iter.next())
        println(iter.hasNext())
        println(iter.add(8))
        println(list)

        println(iter.next())
        println(iter.set(7))
        println(list)
        println(iter.remove())
        println(list)
    }

144. MutableSet 인터페이스 살펴보기 : MutableCollection<E> 상속. 따로 추가된 멤버는 없음

    fun main() {
        val set:MutableSet<Int> = mutableSetOf(1,5,7)
        println(set)

        println(set.add(3))
        println(set)

        println(set.remove(1))
        println(set)

        println(set.addAll(listOf(9,6,7)))
        println(set)
    }

145. MutableMap 인터페이스 살펴보기 : Map<K,V> 상속

    public fun put(key: K, value: V): V?                            --> 키와 값 한 쌍을 추가하고 null 반환. 키가 이미 있다면 해당 키 V 값 교체
    public fun remove(key: K): V?                                   --> 키와 연관된 값 삭제 후 삭제 값 반환. 값 없으면 null 반환
    public fun remove(key: K, value: V): Boolean {                  --> 키와 값 둘 다 일치하는 쌍을 삭제. 있으면 true 실패하면 false
    public fun putAll(from: Map<out K, V>): Unit                    --> from 에 있는 모든 키와 값 쌍을 추가.
    public fun clear(): Unit                                        --> 모든 쌍 삭제
    override val keys: MutableSet<K>                                --> MutableSet 타입으로 오버라이딩
    override val values: MutableCollection<V>                       --> MutableCollection 타입으로 오버라이딩
    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> --> MutableSet<MutableMap.MutableEntry<K, V>> 으로 오버라이딩딩
    public interface MutableEntry<K, V> : Map.Entry<K, V> {         --> 한 쌍을 표현하는 중첩 인터페이스. 값 변경하는 setValue 추가, 반환은 이전 값
        public fun setValue(newValue: V): V
    }
    ---------------------------------------
    fun main() {
        val map:MutableMap<String,String> = mutableMapOf()
        println(map)

    //    println(map.put("인사","Hi"))
    //    println(map)

        println(map.put("작별","Bye"))
        println(map)

        map["인사"]="Hello"
        println(map)

        println(map.putAll(mapOf("메롱" to "merong", "안녕" to "잘지내")))
        println(map)

        println(map.remove("인사"))
        println(map)

        map["인사"]="hi"
        println(map)
        println(map.remove("인사","hi"))
        println(map)

        println(map.remove("인사","hello"))
        println(map)

        println(map.clear())
        println(map)
    }

146. Sequence 인터페이스 살펴보기 : List 처럼 일련의 데이터를 표현하나, 데이터를 lazy 하게 계산함

    interface Sequence<out T>{
        operator fun iterator(): Iterator<T>        --> Iterator 만 들어있음. 사실상 Iterable 인터페이스와 같음
    }
    -----------------------------------------
    fun main() {
        val seq:Sequence<Int> = sequenceOf(1,2,3)   --> sequenceOf 함수는
                                                        fun <T> sequenceOf(vararg elements:T):Sequence<T>
        for(i in seq)
            print("$i ")
    }

147. 콜렉션 원소 타입 변환하기 : map 계열의 확장 함수를 이용하면 Collection<T> 를 Collection<R> 로 변환 가능
    public inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {
        return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)
    }
    public inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {
        return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)
    }
    public inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {
        return mapNotNullTo(ArrayList<R>(), transform)
    }
    --------------------------------------------
    fun main() {
        val origin = listOf(65,66,67,68,69)
        println(origin.map{it.toChar()})                --> map 에 함수 리터럴 {it.toChar()} 전달하여 Int -> Char 타입 변환

        println(origin.mapIndexed{index, element ->     --> 변환 함수에 index 추가
            println("[$index]: $element")
            element.toChar()})

        val to100=1..100
        println(to100.mapNotNull {                      --> 변환 함수가 null 을 반환하면 결과에서 제외.
            if(it%3==0) it                                  3의 배수이면 그대로 반환하고 아니면 null 을 반환하여 3의 배수만 남도록
            else null
        })
    }

148. 콜렉션 중 원하는 원소 걸러내기

    public inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {
        return filterTo(ArrayList<T>(), predicate)
    }
    public inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {
        return filterIndexedTo(ArrayList<T>(), predicate)
    }
    public inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {
        return filterIsInstanceTo(ArrayList<R>())
    }
    public inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {
        return filterNotTo(ArrayList<T>(), predicate)
    }
    public fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {
        return filterNotNullTo(ArrayList<T>())
    }
    ------------------------------------------------
    fun main() {
        val to50=1..50

        println(to50.filter { it%4==0 })
        println(to50.filterNot { it%4==0 })
        println(to50.filterNotNull())
        println(to50.filterIndexed { index, element -> element>20 })
        println(to50.filterIsInstance<Long>())
    }

149. 콜렉션 정렬하기
    public fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {
        if (this is Collection) {
            if (size <= 1) return this.toList()
            @Suppress("UNCHECKED_CAST")
            return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()
        }
        return toMutableList().apply { sort() }
    }
    public fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {
        return sortedWith(reverseOrder())
    }
    ------------------------------------------
    fun main() {
        val list = listOf<Int>(43,76,28,19,22,68)

        println(list.sorted())
        println(list.sortedDescending())
        println(list.sortedBy {
            it.toFloat()
        })
        println(list.shuffled())

        val lotto = 1..45
        println(lotto.shuffled().subList(0,6).sorted())
    }

150. CharSequence 인터페이스 : 문자열과 관련된 클래스가 구현하는 뼈대 인터페이스
                             String, StringBuilder 등 문자열과 관련된 클래스들이 기본적으로 구현하고 있는 인터페이스
                             이름 때문에 Sequence 인터페이스 구현할 것 같지만 전혀 무관. 아무 것도 구현하고 있지 않음
                             CharSequence 인터페이스 자체는 3개 멤버 밖에 없지만, 이를 리시버로 하는 확장 멤버가 무수히 많음
    public interface CharSequence {
        public val length: Int                                                  --> 문자열의 길이
        public operator fun get(index: Int): Char                               --> 문자열의 문자 하나를 [] 로 접근하게 해주는 연산자 멤버 함수
        public fun subSequence(startIndex: Int, endIndex: Int): CharSequence    --> start ~ end 구간의 문자열을 뽑아서
    }                                                                               새로운 CharSequence 로 반환하는 멤버 함수
    -------------------------------------------
    fun main() {
        val seq:CharSequence = "Hello"
        println(seq.length)
        println(seq.get(3))
        println(seq.subSequence(1,4))
    }

151. 접두사/접미사 관련 CharSequence 확장 함수

    fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean
                                    --> 문자열이 지정한 prefix 로 시작하면 true. ignoreCase 를 true 로 지정하면 대소문자 구분 안 함
    fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean
                                    --> 문자열이 지정한 suffix 로 끝나면 true. ignoreCase 를 true 로 지정하면 대소문자 구분 안 함
    fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {
        if (startsWith(prefix)) {
            return subSequence(prefix.length, length)
        }
        return subSequence(0, length)
    }                               --> 문자열이 지정한 prefix 로 시작하면, prefix 삭제하고 나머지 문자열 반환
    public fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {
        if (endsWith(suffix)) {
            return subSequence(0, length - suffix.length)
        }
        return subSequence(0, length)
    }                               --> 문자열이 지정한 suffix 로 끝나면, suffix 삭제하고 나머지 문자열 반환
    public fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {
        if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {
            return subSequence(prefix.length, length - suffix.length)
        }
        return subSequence(0, length)
    }                               --> 문자열이 지정한 prefix 로 시작하고 suffix 로 끝나면, 해당 부분을 삭제하고 나머지 문자열 반환
    -------------------------------------------
    fun main() {
        val str:CharSequence = "http://www.naver.com"
        println(str.startsWith("http://"))
        println(str.endsWith(".com"))
        println(str.removePrefix("http://"))
        println(str.removeSuffix(".com"))
        println(str.removeSurrounding("http://",".com"))
    }

152. 비어 있는 CharSequence 인지 검사하기

    fun main() {
        val emptyStr = ""
        val whiteSpaces = " "
        val nullStr:String? = null

        println(emptyStr.isEmpty())             --> 비어 있는지
        println(whiteSpaces.isEmpty())

        println(emptyStr.isBlank())             --> 공백 문자열인지
        println(whiteSpaces.isBlank())

        println(nullStr.isNullOrEmpty())        --> Null 혹은 비어 있는지
        println(nullStr.isNullOrBlank())        --> Null 혹은 공백 문자열인지
    }

153. CharSequence 가공하기

    fun main() {
        val str = "  hello  "

        println(str.removeRange(0,5))           --> 지정한 범위 제거
        println(str.padStart(20,'*'))           --> 지정한 숫자만큼 문자열을 늘리고 앞 빈 공간에 ' ' 문자 삽입
        println(str.padEnd(17,'*'))             --> 지정한 숫자만큼 문자열 늘리고 뒷 빈 공간에 ' ' 문자 삽입

        println(str.trimStart())                --> 앞 공백 삭제
        println(str.trimEnd())
        println(str.trim())

        println(str.slice(4..6  ))              --> 아래 세 함수 모두 지정한 범위만큼 잘라내어 문자열 반환
        println(str.subSequence(4..6))
        println(str.substring(4..6))

        println(str.reversed())                 --> 문자열 거꾸로 출력
    }

154. CharSequence 쪼개기

    fun main() {
        val hello:CharSequence = "안녕하세요.\n고맙습니다.\n반갑습니다."
        val time:CharSequence = "2018-01-22"

        println(hello.lines())                      --> line 으로 구분하여 list 타입으로 반환
        for(line in hello.lineSequence())           --> line 으로 구분하여 Sequence 타입으로 반환
            println(line)
        println(time.split('-'))                    --> ' '구분자 기준으로 쪼개서 출력.
    }

155. String 클래스 살펴보기 : Comparable 과 CharSequence 인터페이스 구현

    fun main() {
        val one = "Hello"
        val two = "Kotlin"
        val three = "JavaFx"

        println(one+two)
        println(one>two)
        println(two>three)
    }

156. 문자열 찾아 바꾸기

    fun main() {
        val adage = "Love begets love"
        println(adage.replace("love","hate",ignoreCase = true))             --> 일치하는 문자열을 지정한 문자로 교체
        println(adage.replaceFirst("love","compliment",ignoreCase = true))  --> 일치하는 첫 번쨰 문자열을 교체
        println(adage.replaceRange(5..10,"hello"))                          --> 지정한 범위의 문자열 교체
    }

157. StringBuilder 클래스 : 문자열 덧붙이기

    fun main() {
        val builder = StringBuilder().append("2018").append("PyeongChang").append("Olympic")
        val result = builder.toString()
        println(result)
    }

158. Regex 클래스 : 정규식 다루기

    constructor(pattern: String)  --> 정규식 패턴이 담긴 문자열을 저장하는 생성자
    infix fun matches(input:CharSequence):Boolean --> input 이 정규식에 매칭되는지 여부를 반환
    fun replace(input:CharSequence, replacement:String):String --> input 중 정규식 매칭되는 부분을 치환

    fun main() {
        val regex = Regex("[0-9]+")
        val str = "4324235"
        val str2 = "324 6546 5432"

        println(regex matches str)
        println(regex matches str2)
        println(regex.replace(str2,"숫자"))
     }

159. toList 확장 함수 : List 타입으로 변환하기

    fun main() {
        val list: List<Int> = Pair(10,20).toList()              --> Pair 두 인수 타입이 같아야함
        val list2:List<Double> = Triple(1.1,6.25,8.15).toList()  --> Triple 세 인수 타입이 같아야함

        println(list)
        println(list2)
    }

160. run 확장 함수: 코드 중복 줄이기

    fun main() {
        val a = 10
        val b = 5

        (a*b-2*a).run{              --> run 확장 함수의 리시버 함수를 this 로 묶어줌
            if(this>0)
                println(this)
        }
    }

161. let 확장 함수 : 코드 중복 줄이기

    fun main() {
        val a = 10
        val b = 5
        (a*b-2*a).let { result:Int ->       --> run 과 기능은 같음. this 가 매개 변수 result 로 바뀐 것 뿐
            if(result>0)
                println(result)
        }
    }

162. with 함수 : 코드 중복 줄이기

    fun main() {
        val a = 3
        val b = 7
        with(a*a-b*b){          --> with 뒤의 함수가 this 로 전달
            println(this)
            println(-this)
        }
    }

163. apply 함수 : 객체 생성 및 초기화 코드를 표현식 하나로 압축하기

    public inline fun <T> T.apply(block: T.() -> Unit): T
    ------------------------------------
    class Person{
        var name:String = ""
        var age:Int = 0
        var money:Int = 0

        override fun toString(): String = "$name $age $money"
    }
    fun main() {
        println(
                Person().apply {            --> apply 는 리시버를 그대로 반환
                    this.name="Alan"        --> this 는 Person() 의 표현식
                    this.money=70
                }
        )
    }
164. also 함수 : 객체 생성 및 초기화 코드를 표현식 하나로 압축하기

    class Person{
        var name:String=""
        var age:Int=0
        var money:Int=0

        override fun toString(): String = "$name $age $money"
    }
    fun main() {
        println(
                Person().also{person:Person->       --> run / let 과 동일. 매개변수를 생성하여 지정. Person() 표현식이 person 으로 저장
                    person.name="Alan"                  나머진 apply 와 동일한 기능
                    person.age=22
                }
        )
    }

165. lazy 함수 : 게으른 초기화를 하는 프로퍼티 대리자

    class AAA{
        var num:Int = 0
        val num2 by lazy { num*5 }
    }
    fun main() {
        val one = AAA()
        println(one.num2)       --> num2=0 초기화 완료
        one.num=10
        println(one.num2)       --> num2 는 이미 초기화가 됐으므로 num 값 반영 안 됨

        val two=AAA()
        two.num=4
        println(two.num2)
    }

166. BigInteger 클래스 : 매우 큰 정수 보관하기 : Long 의 표현 범위를 넘는 정수를 다룸. Java 라이브러리
                                            BigInteger 클래스는 toString 도 오버라이딩
    fun Int.toBigInteger():BigInteger
    fun Long.toBigInteger():BigInteger

    BigInteger 를 리시버로 하는 확장 함수들

    operator fun BigInteger.plus(other:BigInteger):BigInteger
    operator fun BigInteger.minus(other:BigInteger):BigInteger
    operator fun BigInteger.times(other:BigInteger):BigInteger
    operator fun BigInteger.div(other:BigInteger):BigInteger
    operator fun BigInteger.rem(other:BigInteger):BigInteger
    그 외 다수

    ---------------------------------------------
    fun main() {
        val a=78423343545.toBigInteger()
        val b=25372465331.toBigInteger()

        println(a+b)
        println(a+b*936273.toBigInteger())
    }

167. BigDecimal 클래스 : 매우 작은 실수 보관하기(Double 의 표현 범위를 넘는 실수)

    fun Int.toBigDecimal():BigDecimal
    fun Long.toBigDecimal():BigDecimal
    fun Float.toBigDecimal():BigDecimal
    fun Double.toBigDecimal():BigDecimal
    --------------------------------
    fun main() {
        val a = 3.0000000000003.toBigDecimal()
        val b = 4.0000000000004.toBigDecimal()
        println(a * b)
    }

168. 최댓값, 최솟값 구하기

    public actual inline fun min(a: Int, b: Int): Int       --> (Long, Double, Float 같음)
    public actual inline fun max(a: Int, b: Int): Int
    --------------------------------
    import kotlin.math.max
    import kotlin.math.min

    fun main() {
        println(max(3,7))
        println(max(10.53,1.15))
        println(min(18,13))
        println(min(7.6,20.01))
    }

169. 실수 값 올림/내림/반올림하기

    import kotlin.math.*

    fun main() {
        println("${ceil(3.2)}")
        println("${ceil(3.7)}")
        println("${floor(4.3)}")
        println("${floor(4.9)}")
        println("${round(2.1)}")
        println("${round(2.7)}")
        println("${15.83.roundToInt()}")
        println("${23.58.roundToLong()}")
        println("${377842.12345.roundToLong()}")
    }

170. abs 함수 : 절댓값 구하기

    fun abs(x:Int):Int       --> (Double, Float, Long)
    -----------------------
    import kotlin.math.abs

    fun main() {
        println("${abs(17)}")
        println("${abs(-58)}")
        println("${abs(-63.24)}")
        println("${abs(1.24)}")
    }

171. E, PI: 수학 상수

    const val E:Double
    const val PI:Double
    ------------------------
    import kotlin.math.E
    import kotlin.math.PI

    fun main() {
        println(PI)     --> 원주율
        println(E)      --> 자연 상수
    }

172. hypot 함수 : 빗변의 길이 구하기

    fun hypot(x:Double, y:Double):Double
    fun hypot(x:Float, y:Float):Float
    -----------------------
    import kotlin.math.hypot

    fun main() {
        println(hypot(3.0,4.0))
    }

173. 지수함수

    fun sqrt(x:Double):Double           --> 제곱근
    fun sqrt(x:Float):Float

    fun Double.pow(x:Double):Double     --> 리시버의 x 제곱을 반환. infix 선언이 안 되어 있으므로 연산자처럼 사용 불가
    fun Double.pow(n:Int):Double
    fun Float.pow(x:Float):Float
    fun Float.pow(n:Int):Float

    fun exp(x:Double):Double            --> e^x 값 반환
    fun exp(x:Float):Float

    fun expm(x:Double):Double           --> e^x - 1 반환
    fun expm(x:Float):Float
    ----------------------------
    import kotlin.math.exp
    import kotlin.math.expm1
    import kotlin.math.pow
    import kotlin.math.sqrt

    fun main() {
        println(sqrt(2.0))
        println(2.0.pow(0.5))
        println(exp(2.0))
        println(expm1(2.0))

174. 로그함수

    fun log(x:Double, base:Double):Double
    fun log(x:Float, base:Float):Float

    fun log2(x:Double):Double
    fun log2(x:Float):Float

    fun log10(x:Double):Double
    fun log10(x:Float):Float

    fun ln(x:Double):Double
    fun ln(x:Float):Float

    fun ln1p(x:Double):Double
    fun ln1p(x:Float):Float
    ---------------------------
    import kotlin.math.*

    fun main() {
        println(log(4f,2f))
        println(log2(8f))
        println(log10(10000f))
        println(ln(E))
        println(ln1p(E))
    }

175. 삼각 함수 : Double 또는 Float 타입의 '라디안' 값을 인수로 받음.

    import kotlin.math.*

    fun main() {
        println(sin(PI/4))
        println(cos(PI/4))
        println(tan(PI/4))

        println(asin(PI/4))         --> 삼각 함수의 역함수
        println(acos(PI/4))
        println(atan(PI/4))

        println(sinh(PI/4))         --> 쌍곡선 함수
        println(cosh(PI/4))
        println(tanh(PI/4))

        println(asinh(PI/4))        --> 쌍곡선 함수의 역함수
        println(acosh(PI/4))
        println(atanh(PI/4))
    }

176. toBits, toRawBits 확장 함수 : 실수 타입을 이진수 값으로 가져오기

    fun Double.toBits():Long
    fun Float.toBits():Int
    fun Double.toRawBits():Long
    fun Float.toRawBits():Int
    -----------------------------
    fun main() {
        val normal = 10.0
        val infinite = 10.0/0
        val nan=0.0/0

        println(normal.toBits().toString(2))            --> toString 에 Int 값 인수로 넘기면 해당 숫자 진법으로 문자열 생성
        println(infinite.toBits().toString(2))
        println(nan.toBits().toString(2))

        println(normal.toRawBits().toString(2))
        println(infinite.toRawBits().toString(2))
        println(nan.toRawBits().toString(2))
    }
ㅇ
177. fromBits 확장 함수 : 이진수 값으로부터 실수 값 만들기

    fun Double.Companion.fromBits(bits:Long):Double
    fun Float.Companion.fromBits(bits:Int):Float
    ------------------------------
    fun main() {
        val realNumber:Float = Float.fromBits(0b01000001_00100111_10101110_00010100)
        println(realNumber)
    }

178. Any?.toString 확장 함수 : 값이 null 인 표현식에도 toString 을 호출할 수 있게 해줌(코틀린 내장, 감춰져 있음)

    fun Any?.toString():String = this?.toString()?:"null"
            --> 만약 this 가 null 이라면 this?.toString()? 표현식도 null
            --> Any?.toString() 는 이해를 돕기 위한 상상 코드
    ------------------------------
    fun main() {
        val empty:Int?=null
        val str:String=empty.toString()
        println(str)
    }

179. String?.plus 연산자 확장 함수 : null 값인 String 타입 표현식도 + 연산자 사용 가능

    operator fun String?.plus(other:Any?):String{       --> 이것도 마찬가지로 상상 코드
        return this.toString()+other.toString()
    }
    ----------------------------
    fun main() {
        val nullStr:String?=null
        println(nullStr+"ddd")      --> + 를 호출하면 String 클래스의 plus 가 아닌, String?.plus 가 호출
    }

180. Double 값 검증하기 : Double 타입에는 Nan(Not a Number, 숫자가 아님), Infinite 라는 특수값 들어갈 수 있음

    fun Double.isNaN():Boolean          --> 리시버 값이 isNaN 이면 true
    fun Float.isNaN():Boolean

    fun Double.isInfinite():Boolean
    fun Float.isInfinite():Boolean

    fun Double.isFinite():Boolean
    fun Float.isFinite():Boolean
    -----------------------------
    fun main() {
        val a:Double = 0.0/0.0
        val b:Double = 7/0.0
        val c:Double = 3.2

        print("$a ")
        println(a.isNaN())

        print("$b ")
        println(b.isInfinite())

        print("$c ")
        println(c.isFinite())
    }

181. 인수(Argument) 검증하기 : check 와 require 함수를 이용하여 값이 특정 조건을 만족하지 않을 때 예외 던짐. 보통 매개 변수가 유효한지 검사할 때 사용

    fun check(value:Boolean)
    fun <T:Any> requireNotNull(value:T?):T
    fun require(value:Boolean)
    ---------------------

    fun func(num:Int?){
        checkNotNull(num)               --> 전달한 인수 값이 null 이면 IllegalStateException 예외 던짐
        check(num!! >= 0)               --> false 면 IllegalStateException 던짐
    }
    fun func2(num:Double?){
        requireNotNull(num)             --> 전달한 인수 값이 null 이면 IllegalStateException 예외 던짐
        require(num!!.isNaN())          --> false 면 IllegalStateException 던짐
    }
    fun main() {
        func(10)
        func2(0.0 / 0.0)
    }

182. KotlinVersion 클래스 :사용 중인 코틀린 버전 알아내기

    class KotlinVersion(val major:Int, val minor:Int, val patch:Int):Comparable<KotlinVersion>
    -----------------------------------
    fun main() {
        val kotlinVersion:KotlinVersion = KotlinVersion.CURRENT
        println("${kotlinVersion.major}.${kotlinVersion.minor}.${kotlinVersion.patch}")
        println(kotlinVersion.isAtLeast(1,1,0))         --> 해당 버전 이상인지 확인
    }

183. exitProcess 함수 : 어디서나 프로그램 종료하기

    inline fun exitProcess(status:Int):Nothing
    -------------------------------------
    import kotlin.system.exitProcess

    fun something(num:Int){
        if(num<0)
            exitProcess(0)          --> 0을 전달하면 정상 종료, 0 아닌 수를 전달하면 비정상 종료
    }
    fun main() {
        something(-1)
        println("Hello")
    }

184. 코드 성능 측정하기 : measureTimeMillis, measureNanoTime

    fun measureTimeMillis(block:()->Unit):Long  --> 매개 변수 없고 반환 타입이 Unit 인 함수를 block 매개 변수로 받음. 밀리 초 단위 반환
    fun measureNanoTime(block:()->Unit):Long    --> 나노 초 단위
    -------------------------
    import kotlin.system.measureNanoTime
    import kotlin.system.measureTimeMillis

    fun main() {
        println(measureTimeMillis {
            var sum = 0L
            for(i in 1..100000000)
                sum+=i
        })
        println(measureNanoTime {
            var sum = 0L
            for(i in 1..100000000)
                sum+=i
        })
    }

185. 파일 입출력 : 자바 표준 라이브러리에 의존하며, 코틀린 확장 함수가 이를 보조함. JVM 의존성

    import java.io.*

    fun main() {
        val file = File("./hello.txt")
        if(!file.exists())
            file.createNewFile()

        val outputStream:OutputStream = file.outputStream()     --> .outputStream() 은 File 클래스의 멤버가 아닌 코틀린 확장 함수
                                                                    inline fun File.outputStream():FileOutPutStream
        outputStream.write(35)                                  --> OutPutStream 은 바이너리 형태로만 출력. 35 라는 값이 바이너리 형태로 출력

        val osw:OutputStreamWriter = outputStream.writer()
        osw.write("파일 입출력")
        osw.close()

        val inputStream:InputStream = file.inputStream()
        println(inputStream.read())

        val isr:InputStreamReader = inputStream.reader()
        println(isr.readText())
        isr.close()
    }

186. FileTreeWalk 클래스 : 디렉토리 순회하기

    fun File.walk(direction:FileWalkDirection = FileWalkDirection.TOP_DOWN):FileTreeWalk

                        --> FileWalkDirection 은 파일 순회 방향을 나타내는 열거 클래스
                        --> FileWalkDirection.TOP_DOWN 은 상위에서 하위로, BOTTOM_UP 은 하위에서 상위로

    fun maxDepth(depth:Int):FileTreeWalk                   --> maxDepth() : 탐색할 하위 디렉토리의 최대 깊이
    fun onEnter(function:(File) -> Boolean):FileTreeWalk   --> onEnter{} : 새로운 디렉토리로 들어왔을 때 호출될 함수를 지정
    -----------------------------------------
    import java.io.File

    fun main() {
        val fileTree:FileTreeWalk = File("./").walk().maxDepth(3).onEnter {
            file -> println("새 디렉토리 방문: ${file.name}")
            true
        }
        for(file in fileTree)
            println(file.name)
    }

187. thread 함수 : 스레드 생성하기  --> JVM 스레드를 생성하므로 의존성 생김

    fun thread(
        start:Boolean = true,                       --> true 를 넘기면 스레드를 생성과 동시에 바로 실행
        isDaemon:Boolean = false,                   --> 데몬 스레드로 만들 것인지 여부 지정
        contextClassLoader:ClassLoader? = null,     --> 스레드에서 사용할 클래스 로더 지정
        name:String? = null,                        --> 스레드의 이름을 지정
        priority:Int = -1,                          --> 스레드의 우선순위 지정. 1~10 사이의 정수를 지정. 높은 숫자가 더 높은 순위
        block:() -> Unit):Thread                    --> 스레드에서 실행할 함수 지정
    ----------------------------------
    import kotlin.concurrent.thread

    fun main() {
        thread(start = true){
            print("Hello")
            Thread.sleep(1000)          --> 지정한 시간(밀리 초)만큼 대기
            print("World")
        }
        Thread.sleep(500)
        print("Kotlin")
    }                                   --> Hello 출력 (500ms) Kotlin 출력 (500ms) World 출력

188. timer 함수 : 타이머 생성하기  --> 미리 설정해 놓은 주기마다 지정한 함수를 실행하게 할 수 있음

    fun timer(
    name:String? = null,                --> 타이머의 이름을 지정
    daemon:Boolean = false,             --> 데몬 스레드 여부
    initialDelay:Long = 0.toLong(),     --> 초기 지연 시간을 밀리 초 단위로 지정
    period:Long,                        --> 주기를 밀리 초 단위로 설정
    action:TimerTask().() -> Unit       --> 매 주기마다 실행할 함수 지정. 리시버 타입의 TimerTask 는 자바의 TimerTask, 타이머의 정보를 가져오거나 중지
    ---------------------------------
    import java.util.*
    import kotlin.concurrent.timer

    fun main() {
        var i=1
        var t: Timer = timer(initialDelay = 1500, period = 250){
            println(i)
            i+=1
        }
        Thread.sleep(2400)
        t.cancel()
    }

189. synchronized 함수 : 스레드 동기화하기

    import kotlin.concurrent.thread

    private var obj:Int = 0

    private fun objPlus(){
        for(i in 1..1000)
            synchronized(obj){          --> inline fun <R> synchronized(lock:Any,block:()->R):R
                obj++                       lock 은 동시 수정으로부터 보호할 객체, block 는 lock 객체를 점유하는 동안 실행할 함수
            }
    }
    fun main() {
        thread{ objPlus()}
        objPlus()
        Thread.sleep(100)
        println(obj)
    }

190. 코틀링네서 자바 코드접근하기 : 타입

    fun main() {
        val rand:Double = Math.random()             --> 코틀린에서 Math.random()을 호출하면 double 타입이 코틀린의 Double 로 변환
        println(rand)

        val buffer:StringBuffer = StringBuffer()    --> 자바의 StringBuffer()를 코틀린에서 사용
        buffer.append("hello, ")                    --> StringBuffer 의 append 메소드는 java.lang.String 타입의 인수를 받지만
                                                        코틀린에서 호출할 때는 kotlin.String 타입으로 변환되므로 문제 없이 리터럴 전달 가능
        buffer.append("world!")
        val result:String = buffer.toString()
        println(result)
    }

191. 코틀린에서 자바 코드 접근하기 : Null 안전성    --> 자바의 참조 타입을 코틀린으로 변환하면 타입 뒤에 ! 붙음
                                                  이 타입이 Nullable 인지 Not-Null 인지 알 수 없다는 뜻. 실제 문법은 아니므로 적으면 오류 발생

    public interface JavaInterface {
       String trim(String str);             --> 만일, 자바에서 이 매개 변수에 절대로 null 이 들어오지 않는다고 보장하고 싶으면
    }
    -----------------------------
    class KotlinClass: JavaInterface{
        override fun trim(str:String?):String = str?.trim()?:""     --> String! 타입은 String? 나 String 로 적을 수 있음. String? 이 안전
    }
    fun main() {
        val javaInterface: JavaInterface = KotlinClass()
        println(javaInterface.trim(" hi "))
    }

    %%
    public interface JavaInterface {
           String trim(String str);             --> 만일, 자바에서 이 매개 변수에 절대로 null 이 들어오지 않는다고 보장하고 싶으면
        }                                           @NotNull 어노테이션 붙이면 됨. 이게 붙은 String 타입은 ! 없이 String 그대로 인식 됨
                                                    @Nullable 어노테이션은 반대로 코틀린에서 String? 로 인식

192. 코틀린에서 자바 코드 접근하기 : 키워드 충돌   --> 코틀린에서는 키워드가 자바에서 식별자로 쓰이는 경우

    import java.util.*

    fun main() {
        val scanner: Scanner = Scanner(System.`in`)     --> 코틀린에는 in 이라는 연산자가 있으므로 사용 불가. 1 옆에 있는 `` 로 감싸주면 됨
    }                                                       특수 문자가 들어간 식별자를 지을 때도 사용. 띄어쓰기도 가능

193. 코틀린에서 자바 코드 접근하기 : SAM 변환  --> 단일 추상 메소드(Single_Abstract_Method), 메소드를 하나만 가진 인터페이스
                                             Runnable, Comparable 등. SAM 변환이란, 함수 리터럴을 특정 인터페이스로 변환하는 것을 뜻함

    fun main() {
        val runnable:Runnable = Runnable { println("SAM!") }    --> Runnable 인터펭스는, 매개 변수와 반환 타입이 없는 추상 메소드를 가짐
        runnable.run()                                              따라서, () -> Unit 형태의 함수로 Runnable 타입 대신 표현 가능
    }                                                               함수 리터럴 앞에 단일 추상 메소드를 가진 인터페이스를 적으면
                                                                    그 인터페이스 타입으로 형식이 변함.
                                                                    { println("SAM!") } 까지는 () -> Unit 타입의 표현식이지만
                                                                    Runnable { println("SAM!") } 은 Runnable 타입의 표현식

194. 코틀린에서 자바 코드 접근하기 : Getter/Setter

    public class JavaClass {
       private int value;
       public int getSomething(){
          return value;
       }
       public void setSomething(int value){
          this.value=value;
       }
       public double getDoubleValue(){
          return 3.14;
       }
       public boolean isGood(){
          return true;
       }
    }
    ---------------
    fun main() {
        val java = JavaClass()
        java.something = 301            --> 자바 클래스에 get---, set--- 으로 시작하는 메소드가 있다면, get/set 를 뗀 프로퍼티로 접근 가능
        println(java.something)

        println(java.isGood)            --> 자바 클래스에 is--- 로 시작하는 메소드가 있다면, 이름 그대로 프로퍼티 접근 가능
        println(java.doubleValue)
    }

195. 코틀린에서 자바 코드 접근하기 : 연산자 오버로딩   --> 자바의 메소드 중, 연산자를 오버로딩하는 이름의 메소드가 있으면 코틀린에서 연산자의 형태로 접근 가능

    public class JavaClass {
       public boolean contains(int any){
          return true;
       }
       public int get(int any){
          return 80;
       }
    }
    ------------
    fun main() {
        val java = JavaClass()
        println(13 in java)         --> 자바 클래스의 contains 가 호출
        println(java[13])
        println(java[28])
        println(java[18])
    }

196. 코틀린에서 자바 코드 접근하기 : 클래스 참조   --> 코틀린 클래스의 인스턴스로부터 Class<T> 타입의 값을 얻어내는 방법

    public class JavaClass {
       public static <T> void printClassInfo(Class<T> clazz){
          System.out.println(clazz.getCanonicalName());         --> 인수로 전달된 클래스의 이름을 출력
       }
    }
    -----------------
    fun main() {
        val number:Int = 26
        val str:String = "2018년"

        JavaClass.printClassInfo(number::class.java)            --> 인스턴스 뒤에 class.java 를 적으면, 자바와 호환되는 Class<T> 타입의 객체 가져옴
        JavaClass.printClassInfo(str::class.java)
        JavaClass.printClassInfo(Double::class.java)
    }

197. 자바에서 코틀린 코드 접근하기 : 패키지 레벨 변수/함수

    val a = 10
    fun func() = println("Hello")
    fun Int.extension() = println(this)
    ----------
    @file:JvmName("MyKotlin")                       --> File2.kt 의 클래스 이름을 File2kt 가 아닌 MyKotlin 으로 만들도록 컴파일러에게 지시

    package ex_kotlin_to_java_package_level

    fun func2() = println("From File2.kt")
    ----------
    public class Main {
       public static void main(String[] args) {
          System.out.println(File1Kt.getA());       --> 코틀린 파일에 선언된 패키지 레벨의 변수/함수들은 파일명kt 클래스의 static 멤버로 들어감
                                                        패키지 레벨 변수는 오로지 Getter 와 Setter 를 통해서만 접근 가능
                                                        변수 a 에 접근하려면 getA() 호출
          File1Kt.func();
          File1Kt.extension(100);                   --> 확장 함수도 파일명kt 클래스의 static 멤버
                                                        File1Kt.extension(100) == 100.extension()
          MyKotlin.func2();                         --> 어노테이션으로, File2kt 의 func2 호출
       }
    }

198. 자바에서 코틀린 코드 접근하기 : 프로퍼티  --> Getter/Setter 형태로만 접근 가능

    class KotlinClass {
        var num:Int = 0
    }
    ------------
    public class Main {
       public static void main(String[] args) {
          KotlinClass kotlin = new KotlinClass();
          kotlin.setNum(16);
          System.out.println(kotlin.getNum());
       }
    }

   ------------------------------------------------------
    class KotlinClass {
        @JvmField                                   --> 이 어노테이션 붙이면 자바에서 필드로만 접근 가능
        var num:Int = 0
    }
    ------------
    public class Main {
       public static void main(String[] args) {
          KotlinClass kotlin = new KotlinClass();
          kotlin.setNum(16);                        --> 어노테이션으로 kotlin.num = 16; 으로 써야함
          System.out.println(kotlin.getNum());      --> 어노테이션으로 kotlin.num 으로 써야함
       }
    }
   ------------------------------------------------------
    class KotlinClass {
        var num:Int = 0
        @JvmName("getter")get                       --> 자바에서 프로퍼티에 접근하는 이름 지정하기
        @JvmName("setter")set                       --> 자바에서 프로퍼티에 접근하는 이름 지정하기
    }
    ------------
    public class Main {
       public static void main(String[] args) {
          KotlinClass kotlin = new KotlinClass();
          kotlin.setNum(16);                        --> 어노테이션으로 kotlin.setter(16); 으로 써야함
          System.out.println(kotlin.getNum());      --> 어노테이션으로 kotlin.getter() 으로 써야함
       }
    }

199. 자바에서 코틀린 코드 접근하기 : 선언된 객체

    object KotlinObject {
        var num = 52
        fun hello() = println("hello")
    }
    ---------------------
    public class Main {
       public static void main(String[] args) {
          System.out.println(KotlinObject.INSTANCE.getNum());       --> object 키워드로 선언된 객체는 자바에선 일반적인 클래스
          KotlinObject.INSTANCE.setNum(0);                              INSTANCE 라는 이름의 static 필드 자동 생성.
          KotlinObject.INSTANCE.hello();                                INSTANCE 통해 객체의 프로퍼티와 멤버 함수에 접근 가능
       }
    }
    -------------------------
    object KotlinObject {
        @JvmStatic                          --> 붙여주면, INSTANCE 없이 프로퍼티와 멤버 함수에 접근 가능
        var num = 52
        @JvmStatic
        fun hello() = println("hello")
    }
    ---------------------
    public class Main {
       public static void main(String[] args) {
          System.out.println(KotlinObject.INSTANCE.getNum());   --> 어노테이션으로 KotlinObject.getNum()
          KotlinObject.INSTANCE.setNum(0);                      --> 어노테이션으로 KotlinObject.setNum(0);
          KotlinObject.INSTANCE.hello();                        --> 어노테이션으로 KotlinObject.hello();
       }
    }

200. 자바에서 코틀린 코드 접근하기 : 동반자 객체

    class KotlinClass {
        companion object{
            var num = 0
            fun hello() = println("hello")
        }
    }
    --------------
    public class Main {
       public static void main(String[] args) {
          KotlinClass.Companion.setNum(30);
          System.out.println(KotlinClass.Companion.getNum());
          KotlinClass.Companion.hello();
       }
    }

    %% 동반자 객체도 199번의 객체와 마찬가지로 어노테이션 붙여서 static 으로 접근 가능